
DFS(深さ優先探索){
  ABC015 C - 高橋くんのバグ探し
  アンケートアプリのバグを調べる。ユーザに選択肢がK個ある質問をN回回答させる。各回答には数字が割り当てられており、全ての回答の排他的論理和が0になるとバグが発生する。バグが発生する可能性があるか判定する。
  深さ優先探索をする。

  ABC026 C - 高橋君の給料
  木構造を辿る

  ABC029 C - Brute-force Attack
  長さがNでa,b,cで構成される文字列を辞書順に全て出力する。
  dfsする。

  ABC054 C - One-stroke Path
  N頂点M辺の単純な無向グラフがある(N<=8)。頂点1を始点としてすべての頂点を1度だけ訪れるパスは何通りか求める。
  DFSで全て訪れた時は距離を+1する。それ以外は再帰的に呼び出す。

  ABC119 C - Synthetic Kadomatsu
  N本の竹がある。何本かを使い長さがA,B,Cの3本の竹を作る。3種類の操作を行える。1:コスト1で1本の長さを1増やす、2:コスト1で1本の長さを1減らす、3:コスト10で2本の竹を接続し1本にする。最小コストを求める。
  DFSで各竹をA,B,C,どこにも割り当てないの4通りを全パターン試す。

  ABC126 D - Even Relation
  N頂点の木がある。辺には重さがある。同じ色に塗られた任意の2頂点についてその距離が偶数である塗り方を1つ出力する。
  DFSで頂点を辿り、今通っている辺が奇数なら直前の頂点と別の色を付けるようにすると条件に合う塗分けができる。
  
  ABC133 E - Virus Tree 2
  N頂点の木があり、K色の絵具を持っている。2つの異なる頂点の距離が2以下ならば異なる色になるように塗分ける方法を10^9+7で割った余りを求める。
  ある頂点の子のパターン数は(K-2)C(連結頂点数-1) * (連結頂点数-1)!で、これを掛け合わせていく。但し、最初の頂点(根)は(K)C(連結頂点数+1) * (連結頂点数+1)!を掛け合わせる。

  ABC138 D - Ki
  DFSでいもす法をやる

  ABC148 F - Playing Tag on Tree
  N頂点の木の頂点uに高橋君、頂点vに青木君がいる。高橋君、青木君の順に隣接する頂点に必ず移動する鬼ごっこをするとき、高橋君と青木君が同じマスにいるまでに青木君は何回移動するか求める。
  各頂点の高橋君、青木君からの距離を求める。高橋君が先に到着できる頂点のうち、青木君からの距離が最大のものの距離を求める。その距離-1が答え。

  ABC165 C - Many Requirements
  広義単調増加の正整数列Aを作り、決められた条件のスコアの合計値を最大化する
  DFSで枝刈りありの全探索

  ABC199 D - RGB Coloring 2
  N頂点M辺の単純無向グラフがある。各頂点を3色に塗り分ける方法であって、辺で直接結ばれている2頂点は必ず異なる色で塗る方法の数を求める。
  まずUnion-Find等で連結成分を求める。連結な成分の代表からdfsで塗る順番を決めて、次に色を塗るdfsをまわす。条件を満たしたまま最後の着色を完了するパターンを数え上げて、連結成分毎にansに掛け合わせる。

  ABC211 E - Red Polyomino
  N行N列のマス目があり、各マスは白または黒で塗られている。白マスをK個赤く塗る。赤マスが連結であるような塗り方が何通りか求める。
  DFSで全探索する

  ABC220 F - Distance Sums 2
  N頂点の木がある。各頂点について、他の頂点への距離の合計を求める。
  頂点0を根として、各頂点の部分木のサイズを求める。頂点0のみ答え(各頂点への距離の合計)を求める。頂点をシフトして、各頂点で答えを求める。

  ABC224 F - Expensive Expense
  N個の街とN-1個の道路がある。各道路はCiの通行料がかかる。各街で観光する際Diの費用がかかる。ある街からある街へ行き、そこで観光する際にかかる最大コストを各街をスタートした場合についてそれぞれ求める。
  dfsで木の直径を求める(但し、評価は観光コストも含めるが到達場所は頂点で止める工夫が必要)。各解の目的地は直径の両端のどちらかである。直径の両端からdfsをして各街からの答えを求める。

  ABC236 D - Dance
  2N人が舞踏会に参加する。N組作る。各人にはペアになった場合の相性が決められている。ペアの相性のXORの最大値を求める。
  DFSで全探索する。TLEを避けるため、ペアの片割れを番号の最小の人に固定する。計算回数は16*14*...*2まで落とせる。16!!と書くらしい(解説放送より)。

  ABC238 E - Range Sums
  整数列aの長さがNである事が分かっている。区間lからrの和の情報がQ個与えられたとき、aの全要素の和を特定可能か判定する。
  l-1,rの辺を張ったグラフを作り、0とNが連結であるかdfs等で判定する。連結であるか判定できればよいのでUnion-Findでも可。

  ABC251 F - Two Spanning Trees
  N頂点M辺の無向グラフGが与えられる。Gの2つの全域木T1、T2を1組構成する。
  T1は頂点1を根とする根付き木とみなしたとき、GのうちT1に含まれない辺の両端はT1において祖先と子孫の関係にある。
  T2は頂点1を根とする根付き木とみなしたとき、GのうちT2に含まれない辺の両端はT2において祖先と子孫の関係にない。
  T1はdfs、T2はbfsで構築する。

  ABC255 F - Pre-order and In-order
  N頂点の二分木を考える。行きがけ順と帰りがけ順が与えられるので元の木を構築する。構築不可なら-1を出力する。
  int f(int pre_st, int in_st, int len)としてrootを返す。

  ABC267 F - Exactly K Steps
  https://atcoder.jp/contests/abc267/tasks/abc267_f

  ABC280 F - Pay or Receive
  N個の街とM本の道路がある。道路を順方向に通行するとcポイントを得、逆方向は-cポイントを得る。Q個の、街xから街yに向かう際の増加ポイントの最大値を求めるクエリを処理する。但し到達不可ならnan、無限に増やせるならinfを出力する。
  連結でないならnan、ポテンシャルが不一致ならinf、それ以外ならポテンシャルの差を求める。各街を始点としてdfsを行い、グループ分け、ポテンシャル不一致判定、ポテンシャルを前計算する。

  ABC281 F - Xor Minimization
  非負整数列Aがある。非負整数xを選び、Aの全ての要素に対してXORを取った後の最大値をMとする。Mの最小値を求める。
  上の桁から考える。2進数表示である桁kに異なる数字があればその桁を消せない。その桁kの数が0,1でグループ分けして、グループ分けされたそれぞれの最大値の内小さい方を採用して1<<kを加えたものが答え、グループないの最大値を再帰的に求める。

  ARC022 C - ロミオとジュリエット
  N個の村があり、各村はN-1本の道で行き来できる。ロミオとジュリエットが最も離れた2つの村に引っ越す。それらの村を求める。
  木の直径を求める

  ARC030 B - ツリーグラフ
  木のいくつかの頂点に宝石が置いてある。根から開始して全ての宝石を回収して根に戻る経路長の最小値を求める。
  訪問する必要のあるところのみ訪問するdfsをする。dfs1回で書いたが、2回の方が簡単かもしれない。

  AGC013 B - Hamiltonish Path
  連結な単純無向グラフがある。2個以上の頂点を通り、同じ頂点を2度以上通らないパスで、パスの少なくとも一方の端点と直接辺で結ばれている頂点は必ずパスに含まれるようなものを求める。
  起点を適当にとり、辿れるだけ辿る。

  AGC033 C - Removing Coins
  木でゲームをする。N頂点にはコインが1枚ずつ置いてあり、2人で交互に操作する。操作は頂点を1つ指定し、そこのコインをすべて取り除き、木上に残ったコインを全て指定した頂点方向に移動するもので、操作できなければ負け。
  木の直径を1または2減らすゲームに置き換えられる。木の直径を求めて、直径を3で割った余りが1なら後手、そうでないなら先手が勝ち。

  典型90 003 - Longest Circular Road（★4）
  木の直径を求める

  典型90 072 - Loop Railway Plan（★4）
  マス目の山を通らないように1周の鉄道を引く。鉄道の長さの最大値を求める。
  DFSで進めなくなったら戻り、スタート地点に戻ったら答えを更新する。

  鉄則 B65 - Road to Promotion Hard
  社員が木構造になっている。部下がいない社員の階級は0であり、部下がいる社員の階級は直属の部下に置ける階級の最大値に1を足した値である。各社員の階級を求める。
  木上でdfsをしてdpする。

  M-SOLUTIONSプロコンオープン D - Maximum Sum of Minimum
  N頂点の木と、N個の正の整数ciがある。2つの端点に書かれた整数の内小さい方を辺に書き込む。それらの数字の合計をスコアとする。スコアの最大値を求め、それを達成する整数の書き込み方を1つ構成する。
  どこかからdfsをして、到着した頂点に大きい方から数字を書いていくと答え。合計値はcの合計から最大のcを引いたもの。

  Code Formula 2014 予選B C - 仲良し文字列
  文字列Aをちょうど3回スワップして文字列Bに変換できるか判定する。
  含まれる文字が異なればNO、異なる文字が6文字以上ならNO、交換方法を全パターン試すことをdfsで3回まで繰り返す。交換後に一致する場合、試行回数が1,3回目ならOK。または同じ文字が2つ以上含まれているものがあれば2回目でもOK。

  パナソニックプログラミングコンテスト2020 D - String Equivalence
  2つの文字列S,Tに対しsi=sj且つti=tj,si!=sj且つti!=tjのいずれかが成立するとき同型という。同型な文字列同士の内辞書順最小のものを標準型という。長さNの標準系の文字列を全て辞書順で昇順に出力する。
  先頭から文字をdfsで決めていく。次に使える文字はこれまでに使用した文字の1つ先まで。dfs(1手前の作成文字列,これまでに使用した辞書順最後の文字)とする。
}
BFS(幅優先探索){
  ABC021 C - 正直者の高橋くん
  町aからbまで最短距離で移動するときのパターン数を求める。
  BFSを行い、初めて到達するときはその町のパターン数に前の町のパターン数を代入。既に距離+1で到達可能と分かっているなら、パターン数を足し合わせる。それ以下で到達可能と分かっているならスキップする。

  ABC067 D - Fennec VS. Snuke
  頂点に1からNまでの番号がついた木でFennecとSnukeがゲームをする。最初頂点0は黒、頂点Nは白で、他は無色である。Fennecは白い頂点に隣接した何れかの無色の頂点を黒く塗り、Snukeは黒で同じことを交互に行う。塗れなくなったら負け。どちらが勝つか求める。
  各人の各頂点への距離を求める。FennecはSnuke以下の距離の頂点を取れる。取れる頂点数がSnukeより大きければFennecの勝ち(同じなら先手のFennecの負け)。
  BFSで実装したが、距離を求めるだけなので、DFSでもよい。

  ABC132 E - Hopscotch Addict
  有向グラフ上で頂点SからTまでけんけんぱをする。Tにちょうど移動できるなら最小回数を、移動できないなら-1を出力する。
  dist配列をけんけんぱに応じて3つ用意して、BFSをする。

  ABC142 F - Pure
  N頂点M辺の有向グラフGがある。全ての頂点の入次数が1、出次数が1であるようなGの誘導部分グラフの頂点を出力する。存在しなければ-1を出力する。誘導部分グラフはVの部分集合であり、Eの両端点がともに含まれる辺を全て含む集合である。
  各頂点からBFSを開始し、最小サイズのサイクルを求める。グラフの頂点を求めるために頂点を辿るときに前の頂点をpre[]に保存していく。

  ABC146 D - Coloring Edges on Tree
  木の辺を各頂点に繋がっているものがすべて別の色になるように塗り分ける
  辺に番号を付けて各辺の色を管理する
  DFSでも解ける

  ABC151 D - Maze Master
  HxWのマス目の迷路の最大距離を求める

  ABC161 D - Lunlun Number
  queueを使ったBFS,小さい方からK番目のルンルン数を求める

  ABC168 D - .. (Double Dots)
  queueを使ったBFS,最短経路の方向を求める

  ABC170 F - Pond Skater
  H,Wマスのグリッドがある。グリッドには蓮の葉が浮かんでおり、そのマスには入れない。一回の移動で1方向に1マス以上Kマス以下移動できるとき、スタートからゴールまで最小何回の移動で到達可能か求める。
  BFSで4方向見るが、今の場所から見ていき自分以下が現れたら見る必要なし。距離が既に入っているマスを越えた先まで見るが処理の重複を防ぐため、chminの更新条件はそのまま入れる。

  ABC184 E - Third Avenue
  2次元グリッドをスタートからゴールまで移動する時の距離を求める。同一テレポーター間はコスト1で移動できる。
  BFSの遷移先にテレポーターも入れる。一度使ったテレポーターと同じテレポーターは消す。
  
  ABC197 F - Construct a Palindrome
  単純とは限らない連結な無向グラフがある。辺iは頂点Aiと頂点Biを結んでおり文字Ciが書かれている。頂点1から頂点Nへのパスを選び、途中の文字を回文にできるか判定し、あるならば回文の長さの最小値を求める。
  dp[a][b]=a,bにいるときの最小手数、としてbfsをする。解の存在条件はa=b or (na=b and nb=a)で、回文の長さの最小値はdp[N-1][0]。

  ABC218 F - Blocked Roads
  N頂点M辺の有向グラフがある。各辺のみ通れないときの頂点1からNまでの最短距離をそれぞれ出力する。辿り着けない場合は-1を出力する。
  まず最短経路を求める。この計算量はM。最短経路以外の辺を消すときは最短距離が答え、最短経路の辺を消すときは最短距離を再計算する。再計算回数は高々Nなので間に合う。

  ABC224 D - 8 Puzzle on Graph
  9個の頂点とM本の辺からなる無向グラフと8つのコマがある。頂点は1から9まで、コマは1から8までの番号がついている。初期状態が与えられる。コマは隣接する頂点にコマがない場合、移動できる。コマの番号と頂点の番号が全て一致したときを完成とする。完成可能なら最小手数を出力し、不可能なら-1を出力する。
  vecをキーにしたmapで最短距離を管理し、BFSをする。

  ABC234 E - Arithmetic Number
  等差数のうち、X 以上で最小のものを求める。等差数とは隣の桁の数との差異がすべて同じ正の整数のことである。
  0からスタートして、右の桁に1から9までをくっつけたものを作り、等差数の条件を満たすならqueueに追加していく。X以上になったら出力する。

  ABC241 F - Skate
  H行W列のスケート場がある。スケート場にはN個の障害物がある。1回の移動で上下左右の何れかを選び、障害物の手前で停止する。スタートからゴールに停止するまでの最小手数を求める。到達不可なら-1を出力する。
  障害物の4近傍に頂点を生成し、bfsする。辺は陽に持たず、現在地から到達可能な障害物があるか判定してから生成する。障害物はx,y方向に別々にmap<int,set<int>>で管理する。

  ABC244 F - Shortest Good Path
  N頂点M辺の単純無向グラフがある。次の2条件を満たす整数列をパスと呼ぶ。
  1.全ての数が1以上、N以下
  2.隣り合う要素は辺で直接結ばれている
  Sを長さNの文字列とする、次の条件を満たすとき、パスAをSに関する良いパスと呼ぶ。
  si=0ならAに含まれるiの個数は偶数、1なら奇数
  Sとして考えられる文字列全てについて、Sに関する良いパスのうち最短のものの長さの総和を求める。
  状態を頂点とみなしたグラフでbfs。dp[状態][現在地]=距離としてbfsで順番に求める。その後、各SについてN頂点のうち最小のものを探してansに加える。

  ABC254 E - Small d and k
  N頂点M辺の単純無向グラフがある。各頂点の次数は3以下である。Q個のクエリについて、頂点xiとの距離がki以下であるような頂点番号の総和を求める。但しkiは3以下である。
  bfsをする。但しdistをviにすると毎回の生成でO(N)かかるのでmapで持つ。

  ABC292 E - Transitivity
  N頂点M辺の単純有向グラフがある。次の操作を0回以上行える。相異なる頂点x,yであってxからyへの有向辺が存在しないようなものを選びxからyへの有向辺を追加する。このグラフが相異なる頂点a,b,cのすべてについて、aからbへの有効辺とbからcへの有向辺がともに存在するならaからcへの有向辺も存在するようにするための最小の操作回数を求める。
  最終的なグラフはある頂点から到達可能な頂点へは有効辺が張られているようなものになる。各頂点からbfsで到達可能な頂点数を求めて和を取るとその辺数が分かるので、そこからMを減じると追加すべき辺の数が求められる。

  ARC011 C - ダブレット
  スタートとゴールの単語が与えられ、途中の単語の候補も与えられる。単語の1文字のみを変更する操作を繰り返すことでスタートからゴールに辿り着くまでの最小操作回数と辿る単語を求める。不可能なら-1を出力する。
  グラフを作ってBFS。前の頂点を記録しながら進む。

  Indeedなう（予選B） C - 木
  木の頂点1を選ぶ。今まで選ばれた頂点と隣接する頂点のうちまだ選ばれていない頂点を選ぶ事を繰り返す。頂点の選び方のうち、辞書順で最小のものを求める。
  min_priority_queueで選んでいく。
}
グラフ{
  ARC111 C - Too Heavy
  N人の人とN個の荷物がある。人はそれぞれ体重があり、荷物はそれぞれ重さがある。はじめ人iは荷物piを持っている。人は体重以上の荷物を持つと疲れて以降の操作に参加できなくなる。2人の荷物を交換して全員が自分と同じ番号の荷物を持った状態にできるか判定し、できるなら操作回数が最小であるものをひとつ構成する。
  (解説とは逆方向のグラフで解いた)始めの状態で、自分と異なる荷物を持っておりその荷物が自分の体重以上ならば達成不可、それ以外なら達成可能。人→自分の荷物を持っている人の有効辺を貼ったグラフを作る。体重が軽い人から交換する。
}
ダイクストラ法{
  ABC022 C - Blue Bird
  N個の家とM個の双方向に通行できる道がある。1つ以上の道を通り、家1に戻る最短経路の長さを求める。
  1つ道を通った後で、同じ道を通らないように家1への最短経路を求める。
  想定解はダイクストラではない。頂点1に隣接する辺を除いたグラフでワーシャルフロイドを使い各頂点間の最短経路を前計算し、頂点1に隣接する頂点のうち2つ選ぶ操作を全通り試すもの。

  ABC035 D - トレジャーハント
  N箇所の町と一方方向の道がM本あり、それぞれの道は移動にci分かかる。T分間のトレジャーハントに出かける。町1を出発し、T分の時点で町1にいる必要がある。各町では滞在時間毎に稼げる金額が設定されている。
  滞在する町は1箇所、各町について到達までの時間と、帰りに必要な時間を求める。行きのグラフと帰りの逆順のグラフを受け取り、2回ダイクストラを実施する。その後、どの頂点に滞在すべきか調べる。

  ABC191 E - Come Back Quickly
  N個の待ちをM本の一方通行の道が結んでいる。多重辺とループがあるかもしれない。各町を出発して1本以上の道を通り、最初の町に戻るルートが存在すれば時間の最小値を求める。
  1つ進んだ状態をキューに入れてダイクストラをスタートさせる。これを各都市で実行する。

  ABC204 E - Rush Hour 2
  N個の都市とM本の道路がある。時刻tに道路iの通行を始めると移動にCi+floor(Di/(t+1))の時間がかかる。各都市を整数時刻に出発する際の都市Nに到達する最速の時刻を求める。
  各都市にはなるべく早く到着した方がよい。各都市からの出発時刻の最適値はt=d^(1/2)-1、切り捨てを考慮してt=sqrt(d)-1,t=sqrt(d)の両方を試せばよい。この時刻までに到着できない都市では即座に出発する事にし、ダイクストラをする。

  ARC064 E - Cosmic Rays
  xy平面上でスタートからゴールまで移動する。好きな向きへ速さ1で移動可能。平面上にはN個の円形のバリアがある。バリア外は宇宙線が降り注いでいる。移動中に宇宙線を浴びる時間の最小値を求める。
  スタート、ゴールに半径0のバリアが張っていることにする。移動経路の候補は各バリアの中心を結ぶ直線としてよい。それらのグラフを作り、ダイクストラをする。

  ARC150 C - Path and Subsequence
  N頂点M辺の連結無向グラフがある。長さNの整数列Aと長さKの整数列Bが与えられる。頂点1からNへの任意の単純パスに対し、Bは(Av1,..,Avk)の部分列になるか判定する。
  スタートから出発して各頂点にBをどれだけ進めずに到達出来るか求める。頂点NにBを進め切らずに到達出来るならNoにでき、そうでないならYes。

  PAST 201912-open J - 地ならし
  H*Wのマスがあり、左下隅、右下隅、右上隅以外は未整備。各マスの整備に必要な費用が与えられる。3点を連結にする最小費用を求める。
  経由点を全探索して最小値を求める。隅の頂点から各点への最短距離はダイクストラで前計算。
  
  CODE FESTIVAL 2014 Easy C - 身体バランス
  N個の街とM個の道がある。各距離はdiである。sからの距離とtからの距離が等しい街の番号を求める。存在しない場合-1を出力する。
  s,tそれぞれから各町までの最短距離をダイクストラで求め、判定する。

  SoundHound Inc. Programming Contest 2018 -Masters Tournament- D - Saving Snuuk
  n個の都市を行き来するm本の電車がある。各電車は円の運賃とスヌークの運賃が設定されている。各都市で円からスヌークへの両替が可能で、両替時に1円=1スヌークですべて両替する。都市sから都市tに行くときに都市tで持っているスヌークの最大値を求める。
  また、i年後に都市iの両替所が閉鎖されるので0からN-1年後についてそれぞれ求める。
  Sから円、Tからスヌークのみを使ったときの各都市へのコストを求める。N-1年後から徐々に両替所が使えるようになっていくと考え、最小コストを求めていく。

  ZONeエナジー プログラミングコンテスト “HELLO SPACE” E - 潜入
  2次元平面上で(1,1)から(R,C)に移動する。左右上方向にはそれぞれコストが設定されており、下方向には1+移動距離のコストがかかる。目的地までの移動コストの最小値を求める。
  下方向の移動のためそのままではグリッド間の変数の合計がR^2*Cになる。そこで1階,2階に分けて2階は下への移動に1かかり、1→2階の移動はコスト1、2→1階の移動はコスト0としてダイクストラする。

  第二回全国統一プログラミング王決定戦予選 D - Shortest Path on a Line
  一直線上にN個の点があり、順に1からNまでの番号がついている。LからRの範囲とCがM個与えられる。LからRの間の全頂点間にコストCの無向辺を張る。点1から点Nまでの最短路の長さを求める。
  1からNまで順番に見ていくと最短距離は単調増加になる。Nから順に1つ前にコスト0の辺を張り、各クエリでLからRにコストCの辺を張っていくとダイクストラで答えを求められる。
}

拡張ダイクストラ法{
  ABC164 E - Two Currencies
  N個の都市とM本の鉄道がある。金貨を無限枚、銀貨をS枚持って都市1にいる。各鉄道は運賃銀貨Ai枚、移動時間Bi分である。各都市で金貨1枚をCi枚に交換でき、金貨1枚当たりDi分で交換できる。各都市への移動にかかる最小時間を求める。
  dp[i][j]を頂点i,銀貨j枚を達成する最短時間として、ダイクストラ法で遷移させる。無駄に多い銀貨をカットする事に注意する。
}

ベルマン・フォード法{
  ABC061 D - Score Attack
  N頂点M辺の重み付き有向グラフがある。頂点1から頂点Nまで移動させ、通った辺の重みの合計をスコアとする。スコアの最大値を求める。無限大の場合はinfと出力する。
  ベルマン・フォード法のように処理する。N回目のループで頂点Nが更新されるならばinfを出力する。

  ABC137 E - Coins Respawn
  有向グラフがあり、各辺の上にCi枚のコインが置かれている。頂点1から頂点Nまで向かうときのコインの最大値を求める。但し、コインは通り過ぎると再出現し、ゴール時に通った辺の数*p枚支払う。所持コインが足りない場合は0枚になる。
  コインの枚数からp減じ、正負を反転させる。このグラフの上でベルマンフォードをする。但し、ゴールに無関係な閉路で発生する負のループを無視するため、辺の方向を逆転させたグラフでdfsを行い、ゴールに到達出来ない頂点を求めておき、そのような頂点では更新を行わないようにする。最後に求められたコストの正負を反転させたものが答え。
}

ワーシャルフロイド{
  ABC012 D - バスと避けられない運
  バス停がN個あり、路線がM個ある。各路線はa,b間を時間tで移動する。あるバス停を決めて任意のバス停に移動するとき、移動時間の最大値の最小値を求める。
  ワーシャルフロイドで全バス停間の移動時間を求める。その後、バス停1つずつに注目して最大値の最小値を求める。

  ABC051 D - Candidates of No Shortest Paths
  N頂点M辺の重み付き無向連結グラフが与えられる。どの異なる2頂点間の、どの最短経路にも含まれない辺の数を求める。
  各頂点間の最短距離を求めておく。すべての辺をひとつずつ、どこかで使われるか判定する。始点を全パターン試し、始点からaまで+cが、始点からbまでの距離と同じなら使われている。

  ABC073 D - joisinos travel
  N個の町とM本の双方向な道がある。R個の町を訪れるとき、移動距離が最小となるように決めた時の移動距離を求める。
  ワーシャルフロイドで全頂点間の距離を求めた後、next_permutationで全パターンを調べる。

  ABC074 D - Restoring Road Network
  N個の都市間の最短距離が示したと思われるN×Nの表がある。これを満たす道路の構造があるか判定する。存在する場合は道路の長さの総和の最小値を求める。
  ワーシャルフロイドを逆に使う。他の2本を使って達成できるなら、その辺は不要。途中2本でより短い距離にできるものが現れたら達成不可能。

  ABC143 E - Travel by Car
  N個の町とM本の道がある。i本目の道はAiとBiを双方向に結び、長さはCiである。車の燃料タンクの容量はLリットルで距離1で1リットル消費する。待ちでタンクが一杯になるまで補給できる。Q個のクエリで与えられる町siからtiに移動するときの最小補給回数を求める。移動できない場合は-1を出力する。
  全頂点間の距離を求める。その後、求めた距離がL以下なら1にして、そうでなければINFにする。それに対して再びワーシャルフロイドを用いる。求められたもの-1が補給回数である。
  考え方としては、2回目のワーシャルフロイド後は、補給なしでいけるところは1の辺が張られているのでそこで補給すると考えれば、適切な補給回数になる。

  ABC243 E - Edge Deletion
  N頂点M辺の単純連結無向グラフが与えられれる。辺には長さが設定されている。辺を削除した後も連結であり、全ての頂点対(s,t)について頂点sと頂点tの間の距離が削除前と削除後で変化しないように削除できる辺の数の最大値を求める。
  ワーシャルフロイドで全頂点対の最短距離を求める。全ての辺をまわし、別の頂点を迂回しても最短距離が保たれるかチェック、保たれるならその辺は削除可能。

  ARC035 C - アットコーダー王国の交通事情
  N個の都市と双方向のM本の道路がある。全部の都市間の最短経路長の総和をSとする。これからK本の道路を順番に建設する。各道路を建設した後のSを求める。
  ワーシャルフロイドで全都市間の最短経路長を求める。道路を追加した後のSは、dist[i][j]=min(dist[i][j],dist[i][x]+z+dist[y][j],dist[i][y]+z+dist[x][j])でO(N^2)で求められる。
}

01-BFS{
  ABC176 D - Wizard in Maze
  壁と道からなるマス目を移動する。上下左右の道へはコスト0で移動できる。5*5マスの範囲にコスト1でワープできる。ゴールに移動するのに必要なコストを求める。
  01-BFSで解く

  ABC213 E - Stronger Takahashi
  スタートからゴールまで格子状の区画を移動する。2*2の区画をコスト1で破壊可能で、ゴールに必要な最小コストを求める。
  01-BFSで解く。但し、ARC005と異なりコスト0の移動とコスト1の移動の処理を分離する。

  ABC246 E - Bishop 2
  N×Nのチェス盤がある。マスSに白のビショップを置く。いくつかのマスに白のポーンを置く。ビショップはポーンを飛び越えない範囲で1手で斜めにどこまでも移動できる。Gまでの最短手数を求める。
  直前にどの方向だったか記憶しておき、方向が変わった場合はpush_backする01-BFSをする。

  ARC005 C - 器物損壊！高橋君(https://itliberta.tech/algorithm-01-bfs/)
  スタートからゴールまで格子状の区画を移動する。壁の破壊回数を2回以下でたどり着けるか判定する。
  01-BFSで解く。つまり壁破壊の場合コスト1と考え、コスト0ならdequeのfront、コスト1ならdequeのbackにpushする。

  典型90 043 - Maze Challenge with Lack of Sleep（★4）
  横H縦Wマスのグリッド状の迷路がある。スタートからゴールまでの移動方向が変わる回数の最小値を求める。
  dp[r][c][dir]=方向の変更回数、として01-BFSをする。方向がそのままならpush_front、変わるならpush_backする。
}

グラフ探索以外のマス目の問題{
  ABC018 C - 菱型カウント
  R行C列のマスがあり、いくつかのマスが黒く塗られている。黒マスと被らずに大きさ2K-1のひし形の中心になれるマスの数を求める。
  画像処理のクロージング処理をK-1回行い、周囲K-1マスを除いたマスのうち白いマスの数が答え。

  ABC182 E - Akari
  マス目に電球と壁が置かれている。電球からは壁まで光が届く。光が届くマス目の数を求める
  光の方向別にメモ化再帰して枝刈りしながら光が届くマスを求める。光の方向別に求めるのがポイント。
}

動的計画法(DP){
  ABC015 D - 高橋くんの苦悩
  スクリーンショットに重要度が存在する。合計幅W以下、枚数K以下で最大の重要度を求める。
  幅と枚数を回すDPで求める。幅と枚数を大きい方から回すとin-placeに実行できる。

  ABC017 D - サプリメント
  N個のサプリメントがある、味は1からMまでのいずれかである。1から順番に毎日サプリメントを1つ以上摂取する。同じ味のものは1つまで。摂取方法のパターン数を求める。
  dp[i]=ある日の終了時点でちょうどサプリメントiを摂取するパターン数,としてDPする。遷移元の日を固定して配るとO(N^2)になるが、加算する領域は区間になるのでBITで高速化。区間の左端は必ず右に移動するので想定解は累積和で高速化している。

  ABC040 C - 柱柱柱柱柱
  N本の柱が並んだアスレチックがある。1本目からN本目まで、1個もしくは2個選んで進む。現在の柱と移動先の柱の高さの差の絶対値のコストがかかる。最小コストを求める。
  カエルが跳ぶ問題と同じ。

  ABC044 C - 高橋君とカード
  N枚のカードがある。各カードにはxiが書かれている。これらから1枚以上を選び書かれた数字の平均をちょうどAにする組み合わせは何通りか求める。
  xiからAを減じて、合計が0になる組み合わせは何通りか求める。

  ABC054 D - Mixing Experiment
  AとBの混合比がMa:Mbの溶液Cを作る。Aをai、Bをbiグラム含むci円の薬品がN種類ある。Cの生成に必要が最小価格を求める。
  i個目まで見て、Aがjg、Bがkgの最小コストとしてDPをする。

  ABC099 C - Strange Bank
  ある銀行では、一回の操作で引き出せる金額が1,6,6^2,6^3,...,9,9^2,9^3,...円になっている。ちょうどN円を引き出すには少なくとも何回の操作が必要か求める。
  ある金額を引き出すのに必要な最低回数をDPで求める。
  
  ABC118 D - Match Matching
  N本のマッチ棒を使って作れる整数の中で最大のものを求める。但し使用可能な数字は1から9までの内から特定のものが与えられる。
  dp[i]:i本使って作れる桁数の最大値として求める。先頭から桁数を達成できる範囲でなるべく大きい数字を割り当てていく。割り当てたら使用できる所持しているマッチの本数から引いていく。

  ABC113 D - Number of Amidakuji
  W本の縦線とH+1の高さが与えられる。左上をスタートして左からK番目に辿り着くパターン数を10^9+7で割った余りを求める。
  高さを上から回してDPをする。左上、上、右上から到達するパターン数を一段ずつ加えていく。

  ABC122D - We Like AGC
  整数Nが与えられる。A,C,G,Tからなり、AGCを部分列として含まず、隣接する2文字の入れ替えを1回行いAGCができないパターン数を10^9+7で割った余りを求める。
  末尾3文字を状態として記録したdpを行う。AGC,ACG,GAC,A*GC,AG*Cの5パターンになるものは遷移不可。

  ABC141 E - Who Says a Pun?
  文字列Sが与えられる。Sの連続する部分列として重ならずに2回以上現れるもののうち最長のものの長さを求める。
  文字列の位置を2つの要素とするサイズ|S|^2のdpテーブルを用意する。dpテーブルの右下から、同一の文字ならテーブルの1つ右下の値+1の値に更新する。テーブルの更新後、テーブル全体を走査し、dp[i][j],j-iの小さい方でansを更新して答えを求める。

  ABC145 E - All-you-can-eat
  N種類の料理があり、i番目の料理は食べるためにAi分必要で、美味しさはBiである。T-0.5分までなら注文できる。食べられる料理の美味しさの最大値を求める。
  変わったDP。以下のようなDPを行い、i番目以外の料理でT-1分で作れる美味しさの最大値にi番目の美味しさを加えることをすべての料理で行い、最大値を求める。
  DP1[i][j] = 1～i番目の料理でj分以内に完食できる美味しさの合計の最大値
  DP2[i][j] = i～N番目の料理でj分以内に完食できる美味しさの合計の最大値

  ABC146 F - Sugoroku
  双六に0からNまでのマスがある。一度に1からMまでの距離を移動できる。止まれないマスが文字列Sで与えられる。マス0からスタートしてマスNに最短手数でゴールするときの出目の並びのうち辞書順最小のものを答える。
  ゴールからDPして、そのマスに到達するまでの手数を求める。その後、スタートからどのマスに移動するか求めてDPの復元をする。
  別解として、ゴールからの貪欲法でもよい

  ABC147 E - Balanced Path
  縦H横Wのグリッドがある。各マスには2つの数が書かれている。一方を赤、もう一方を青で塗る。マス(1,1)からマス(H,W)に右または下方向の移動で移動するとき、経路上の赤の合計と青の合計の差の最小値を求める。
  各マスの2つの値の差を求め、数をプラスまたはマイナスにしたときの経路上の合計値を最小化する問題にする。あるマスに到達したときに達成できる合計値をDPで求める。数の管理にはbitsetを用いる。

  ABC159 F - Knapsack for All Segments
  整数列Aと正の整数Sが与えられる。f(L,R)をAL,..,ARの要素の部分和がSになるパターン数と定義する。すべての(L,R)の組に対するf(L,R)の和を998244353で割った余りを求める。
  Lを固定してRを増加させたとき、dp[見ているid][合計]=パターン数 として使用するしないで遷移させるとO(N^3)になる。Lに依らず遷移の仕方は同じなので、dp[合計]=パターン数 として見ているidの増加のたびにdp[0]+=1とするとO(N^2)になる。

  ABC162 F - Select Half
  長さNの整数列が与えられる。この中のN/2(切り捨て)個の整数を、どの2箇所も連続しないように選ぶときの和の最大値を求める。
  ○を割り当てるとして、○×○の順に割り当てて、×をNになるまで入れる。奇数は2個、偶数は1個×を追加することになる。dp[i個目まで決めた][j個の×を追加した]として、×を追加する遷移と周期に従ってAの要素を加える遷移をする。

  ABC163 E - Active Infants
  N人の幼児が左右一列に並んでおり、左からi番目の幼児の活発度はAiである。はじめx番目にいた幼児をy番目に移動するとうれしさがAx*|x-y|生じる。幼児を並べ替えたときのうれしさの合計の最大値を求める。
  それぞれの幼児を左右どちらに寄せるか決めると、左右それぞれのグループ内で活発度の高いものから端にするほうが良いと分かる。ここからAiの高いものから左右どちらかの端に配置する貪欲が成立する。dp[i人決めた][左j個埋めた]=うれしさの最大値 としてdpする。

  ABC169 F - Knapsack for All Subsets
  正整数列Aと正整数Sが与えられる。集合{1,..,N}の空でない部分集合Tについてf(T)をTの空でない部分集合{x1,..,xk}であって、Ax1+..+Axk=Sを満たすものの個数と定める。考えられる全てのTに対してf(T)の和を998244353で割った余りを求める。
  ある要素の扱いは、Tに採用されない,Tに採用されるがSの和に使用されない,Sの和に使用されるの3パターン。。dp[(見た個数)][和]=パターン数 としてdpをする。

  ABC175 E - Picking Goods
  マス目にK個のアイテムがある。(1,1)から(R,C)まで、右または下方向のみに移動可能。その場のアイテムは拾っても拾わなくても良い。同じ行のアイテムは3つまでしか拾えないとき、アイテムの価値の合計の最大値を求める。
  dp[r][c][k]:rは行数、cは列数、kは同じ行で拾ったアイテム数としてDPをする。

  ABC178 D - Redistribution
  すべての項が3以上の整数で、その総和がSであるような数列のパターン数をmod10^9+7で求める。 
  区切り位置をDPで求める。

  ABC179 D - Leaping Tak
  マス1からマスNに移動する方法が何通りか求める。移動可能なマス数は最大10個の区間で与えられる。
  累積和を使い1区間の足し合わせをO(1)で行えるようにしてDPする。
  
  ABC183 E - Queen on Grid
  壁と道からなるグリッドがある。クイーンは右・下・右下方向に壁を飛び越えずに1手で　移動できる。(1,1)から(H,W)まで移動する方法の数をmod(10^9+7)で求める。
  DPだが計算量を削減するために、右・下・右下方向用の累積和を保存する2次元配列を作る。

  ABC185 E - Sequence Matching
  長さNの整数列Aと、長さMの整数列Bがある。それぞれの整数列から長さが同じになるようにいくつかの要素を取り除く。取り除いた要素数をx、AiとBiが一致しないiの数をyとするとき、x+3ならば同色、それ以外は別の色になるように色を塗りなおす。色XをYに塗り替えた時の違和感がDXYで与えられる。違和感の和の最小値を求める。
  解答の説明が難しい

  ABC189 D - Logical Expression
  N個の文字列が与えられる。各文字列はANDまたはORである。値がTrueまたはFalseであるN+1個の変数の組(x0...xN)であり以下の計算後にyNがTrueになるパターン数を求める。
  1.y0=x0
  2.i>=1のときSiがANDならyi=y(i-1) and xi、SiがORならyi=y(i-1) or xi
  dp[i番目][yiの状態]としてDPをする。

  ABC204 D - Cooking
  料理1からNを作る。料理iはオーブンを連続したTi分使うと作れる。2つのオーブンを使えるとき、最短何分で作れるか求める。
  各料理を作り終えるタイミングとして存在しうるものを全て求め、合計時間の半分以上の最小値が答え。今回の制約では二重ループで間に合うが、bitset<100100>で管理すると高速化できる。

  ABC207 E - Mod i
  長さNの数列Aがある。Aをいくつかの連続した空でない部分列Bに切り分ける方法であって、次の条件を満たすものの個数を1000000007で割った余りを求める。全てのiについてBiに含まれる要素の総和がiで割り切れる。
  ;

  ABC210 D - National Railway
  グリッド上に2つの駅を建設する。マンハッタン距離*Cの線路を建設する。建設費用を最小化する。
  左上と右下の組を仮定してi,jの組とi',j'の組を分離する。(Ai'j'+C(i'+j'))+(Aij-C(i+j))。左上の建設費最小値をDPで保存しておく。上下反転してもう一度処理する。

  ABC224 E - Integers on Grid
  H×Wのマスがあり、いくつかのマスには整数が書かれている。コマを数字の書かれたマスに置き、そのマスより真に大きい数字が書かれた、同じ行または列にあるマスに移動させる。数字の書かれた各マスをスタートとして、移動を行える最大数を求める。
  map<int,vi>でマスにかかれた数字毎に、座標をvecで格納する。各行、列でそのマスから移動可能な最大回数を管理する。map内で数字が大きい方から移動可能な最大回数を調べ、それに+1したものがそのマスの最大移動回数。ある数字で移動回数を求め終わったら、各行、列の移動可能な最大回数を更新する。
  
  ABC234 F - Reordering
  文字列Sが与えられる。Sの空でない、連続するとは限らない部分列を並び替えて得られる文字列は何種類あるか、998244353 で割った余りを求める。
  各文字の出現回数をカウントする。dp[i][j]=i種類目まで使って長さjの文字列を作るパターン数とする。文字を1種類ずつ見ていき、対象とする文字を0から限界まで、これまでのあり得る文字列に挿入するパターン数を足し合わせる。

  ABC237 F - |LIS| = 3
  ;
  まだ解法を文字にできない。LIS、要素を添え字にするテクニックが必要。

  ABC244 E - King Bombee
  N頂点M辺の単純無向グラフがある。頂点Sを出発してちょうどK回の移動で頂点Tに到着する経路の内頂点Xを偶数回通るものの数を998244353で割った余りを求める。
  dp[移動回数][現在地点][Xを偶数回or奇数回]=パターン数としてdpする。

  ABC247 F - Cards
  N枚のカードがあり、表にはPi、裏にはQiが書かれている。PおよびQはそれぞれ1...Nの並び替えである。N枚のカードから何枚かを選ぶ方法のうち、1...Nのどの数も選んだカードのいずれかに書かれているようなパターン数を998244353で割った余りを求める。
  各カードの値のペアを辺としてグラフを考えると、条件より複数のサイクルの集合となる。各サイクル毎に考えて辺被覆にするパターン数を掛け合わせるとよい。これは、連続する2辺の内どちらか一方は必ず選ぶパターン数である。

  ABC248 F - Keep Connect
  2以上の整数Nおよび素数Pが与えられる。図のような2N頂点(3N-2)辺のグラフGの辺からちょうどi本の辺を取り除く方法であって、グラフが連結であるものの個数をPで割った余りを求める。
  グラフをコの字が連結されたものと考える。dp[i個目][j本切った][右端の頂点の連結状態]としてDPをする。

  ABC264 F - Monochromatic Path
  各マスが白または黒で塗られたH行W列のグリッドがある。行または列を選び対応するコストを支払う事で行または列の色を全て反転する事ができる。左上から右下に、同じ色のマスのみを通るルートで、右または下のみに移動して到着可能な最小コストを求める。
  dp[y][x][4(行列の状態)]=最小コスト としてdpをする。

  ABC265 E - Warp
  2次元平面の原点にいる。ワープをN回繰り返す。ワープの種類は3種類でそれぞれ現在位置から相対的に移動する。またM箇所に障害物がありこの座標には移動できない。N回のワープによる移動経路は何通りか、998244353で割った余りを求める。
  あり得る座標は限られているのでDPで求める。

  ABC270 D - Stones
  数列Aを使って2人が石取りゲームをする。山にはN個の石がある。2人で交互に数列Aにある要素の内1つを選び、その数だけ山から石を取り除く。石がなくなったときゲームは終了する。二人ともに石の数を最大化するときの先手の石の数を求める。
  dp[山の個数]=先手が取れる石の合計,としてdpする。遷移は今回取る数をA[j]として、dp[i]=A[j]+(i-A[j])-dp[i-A[j]]。

  ABC271 E - Subsequence Path
  N個の都市とM本の一方通行の道がある。1以上M以下の整数からなる長さKの数列Eが与えられる。都市1から都市Nまでいくつかの道を使って移動する方法であって、通る道の番号を通った順番に並べた列がEの部分列になるようなもののうち通る長さの合計値が最小になるものの距離を求める。
  dp[頂点番号]=最短距離として、Eに登場する順番に道を使用した場合の緩和を行う。即ち順番に道を使いchmin(dp[B[e]],dp[A[e]]+C[e])で緩和する。

  ABC275 F - Erase Subarrays
  正整数列Aが与えられる。Aから空でない連続する部分を削除する操作を繰り返して合計を1,...,Mにするために必要な最小の操作回数を1,...,Mのそれぞれについて求める。
  dp[i文字目まで見た][合計j][k最後採用が0,不採用が1]=最小操作回数としてDPする。操作回数は○×の順に現れる組の個数を数えると良い(○は採用,×は不採用)。

  ABC310 E - NAND repeatedly
  0と1からなる文字列Sが与えられる。全ての連続する区間のnandの和を求める。
  dp[0/1の状態]=パターン数、として先頭からnand計算、今回の値の加算、ansに加算を繰り返す。

  ABC315 F - Shortcuts
  チェックポイントがN個ある。1,N以外は省略可能。省略したチェックポイント数Cに応じて追加でC=0なら0,それ以外は2^C-1のペナルティがかかる。移動距離とペナルティの合計の最小値を求める。
  Cは高々20個も考慮すればよい。dp[最後の地点][無視した個数]=最小距離 としてDPする。

  ABC341 F - Breakdown
  N頂点M辺の単純な無向グラフがある。各頂点には正整数Wiが割り当てられており、Ai個のコマが置かれている。グラフ上にコマが存在する限り次の操作を繰り返す。グラフ上のコマを1個選んで取り除き、その頂点sに隣接するいくつかの頂点でWの合計がWx未満であるものを選びそれらの頂点に1個ずつコマを置く。操作回数の最大値を求める。
  Wの小さい順に1個コマが置かれている場合に何手稼げるか求める。ある頂点の値を求めるにはdp[Wの合計値]=回数の合計の最大とする。全体として動的計画法を2重に行う。

  ARC027 C - 最高のトッピングにしような
  スペシャルチケット、通常チケットの2種類があり、トッピングと交換できる。N種類のトッピングがあり、必要なチケット枚数と嬉しさが設定されている。交換時にスペシャルチケットを1枚は使用する必要がある。嬉しさの最大値を求める。
  dp[採用トッピング数][チケット消費数]=嬉しさ としてdpする。dp[残スペシャル][残通常]=嬉しさ として遷移を制限してもいけそう。

  ARC038 B - マス目と駒
  マス目とコマがある。マス目には障害物がある。2人で左上から右下にコマを動かすゲームをする。動かせなくなった方が負け。どちらが勝つか判定する。
  ゴールからDPして、ある位置を受け取ったものが勝利するか判定する。想定解はメモ化再帰

  ARC042 C - おやつ
  遠足に持って行くおやつを選ぶ。合計P円まで持って行け、更にどの1つのおやつについてもそのおやつがなければ合計がP円以下になるなら持っていける。各おかしに値段と満足度が設定されている。達成可能な満足度の合計の最大値を求める。
  最も安いおかしを除いた価格がp以下なら良いので,価格で降順ソートし、dp[値段合計]=最大満足度として毎回chmax(ans,dp[P+a])として求める。実装時の工夫として、大きい方からインラインで処理することで、ぴったりを達成不可でもそれ未満の価格の最大満足度が格納される。上記を実現するため敢えて-INFで初期化していない。

  ARC141 B - Increasing Prefix XOR
  正整数N,Mが与えられる。長さNの正整数列A=(A1..AN)であって以下の条件を満たすものの個数を998244353で割った余りを求める。
  条件1.1<=A1<A2..AN<=M、条件2.Bi=A1^..^AiとしたときB1<..<BN
  条件より各Aは2進数にしたときの桁数がそれぞれ異なる。従ってNがMを2進数表現した桁数を超えていれば0パターン。2進数にしたときの各桁数の数字のパターン数からN個選ぶパターン数をDPで求める。

  AGC043 A - Range Flip Find Route
  H行W列のマス目があり、それぞれ白か黒に塗られている。(1,1)から(H,W)まで右か下だけに移動して移動できるとき良い状態である。矩形範囲の色を反転させる操作を最小何回行うと良い状態にできるか求める。
  (1,1)から(H,W)まで到達するときの色の変化回数の最小値をDPで求める。(1,1),(H,W)がそれぞれ黒のときその値に1を加える。その値を2で割ったものが答え。

  AGC046 B - Extension
  縦A横Bマスのマス目があり全て白く塗られている。現在のマス目に1行または1列加え、加えたマスの内1つを黒くする操作を縦Cマス、横Dマスになるまで繰り返す。マス目の塗られ方の個数を998244353で割った余りを求める。
  ある行数、列数での組み合わせの個数は、1行減らしたものに1行加えるか、1列減らしたものに1列加えたものなので、これらを加える。重複があるので両方に共通する右上のマスのみ使用しないパターン数を減じる。

  TDPC B - ゲーム
  それぞれ価値が設定されたものが積まれた山A,Bがある。2人でいずれかの山を選択して一番上にあるものを取ることを交互に繰り返す。両者が最善を尽くしたときの先手の合計最大価値を求める。
  dp[A山の残数][B山の残数]=この状態で開始した人が得る最大価値 としてdpする。累積和によりこの状態の合計価値を求め、遷移先の価値を減じたものが今回達成可能な価値であり、2つの山の大きい方を採用する。

  TDPC C - トーナメント
  2^K人が参加するトーナメントがある。各人のレートが与えられる。各人が優勝する確率を求める。
  dp[ラウンド数][人番号]=生き残る確率 としてDPする。各ラウンドで人iが戦う可能性のある人は2進表現で工夫して求める。

  典型90 050 - Stair Jump（★3）
  1段かL段上れるとき、N段の階段を上る移動方法が何通りか求める。

  典型90 056 - Lucky Bag（★5）
  N日間にわたって初売りが行われる。各日にはAi,Bi円の福袋が売られる。N日間A,Bどちらかを購入してちょうどS円になる計画があるか判定し、可能ならそれを求める。
  DPしたあと復元する。どこから遷移したか記録せずとも、達成可能かのみ記録してAi,Bi円を引いたものが存在するかチェックするだけでよい。

  キーエンス プログラミング コンテスト 2021 C - Robot on Grid
  H行W列のマス目がある。それぞれのマスにR,D,Xを書き込むことができる。初期状態はKマスに指定の文字が書かれている。残りの3^(HW-K)通りの文字の書き込み方のそれぞれの場合について、左上から右下まで、右または下のみに移動する経路のパターン数を足し合わせてものを998244353で割った余りを求める。
  マスの文字を決めて経路を求めるのではなく、経路を求めてマスの文字のパターン数を求めて足し合わせる。3^(HW-K)通りから始めて、.のマスが出る度に3の逆元を掛け合わせてdpする。

  CODE FESTIVAL 2015 あさぷろ Easy D - ヘイホー君と削除
  ある文字列を2回繰り返してできる文字列を平方と呼ぶ。文字列Sを平方にするために削除する必要がある文字数の最小値を求める。
  区切り位置を全探索し、それぞれの編集距離を求め、それらの最小値が答え。編集距離はN-LCS*2で求めても良い。

  みんなのプロコン2019 D - Ears
  数直線上にすぬけ君がいます。すぬけ君はL個の耳を持っており座標0からLまでの頂点間を散歩する。座標i-0.5の点を通るたびにi番目の耳に石を1個入れる。各耳には目標の石の数が定められており、散歩終了後の目標個数との差の合計の最小値を求める。
  スタート、終了、最小位置、最大位置の4点を考えると通ってきた点の数により達成可能な石の数の偶奇が変化し、好きな数を達成できる。dp[(i個目の耳まで見た)][t個の変化点を通過]=操作回数の最小値としてdpする。

  天下一プログラマーコンテスト2014予選B B - エターナルスタティックファイナル
  N種類のフレーズを組み合わせて文字列Sを作る組み合わせを1000000007で割った余りを求める。
  スタート位置を全探索して、各フレーズを使って終了位置のパターン数に加える。

  三井住友信託銀行プログラミングコンテスト2019 C - 100 to 105
  1個100円から106円までの品物がそれぞれ1000000個売られている。合計金額がX円になるような買い方が存在するか判定する。
  6通りの遷移をするdpをする。

  三井住友信託銀行プログラミングコンテスト2019 E - Colorful Hats 2
  N人の人が一列に並んでおり、赤青緑のいずれかの帽子を被っている。「自分より前に自分と同じ色の帽子を被っている人はAi人いる」という情報が与えられるので、あり得るパターン数を1000000007で割ったあまりを求める。
  cnt[帽子の個数]=あり得る色の数、として毎回あり得る数を掛け合わせて答えを求める。
}

再帰{
  ABC115 D - Christmas
  多次元バーガーを作る。レベル0バーガーはパティ1枚、レベルLバーガーはパン、L-1、パティ、L-1、パンで構成される。下からX層食べる時のパティの枚数を求める。
  各レベルの総枚数、パティの枚数を求めておく。レベルNの下からX枚までのパティの枚数を求める関数を再帰的に作成する。中身はXが5パターンのどこに位置するかで5パターンの分岐をさせる。
}

メモ化再帰{
  ABC037 D - 経路
  数字が書かれたマスがある。好きなマスから好きなだけ動ける(動かなくてもよい)。上下左右により大きなマスに移動できる。ありうる移動経路の個数を10^9+7で割った余りを求める。
  priority_queueで小さいものから4方向に足し合わせて求めた。
  想定解はdfsで求めていき、一度求めた値はメモ化再帰で再使用。
}

ナップサック{
  ABC153 E - Crested Ibis vs Monster
  モンスターの体力はH、N種類の魔法はそれぞれAiのダメージで魔力をBi使用する。体力を0以下にするために必要な最小魔力を求める。
  dp[魔法][ダメージ]=コスト として使用制限なしのナップサックをする。[魔法]はなくしてインラインでいける。

  鉄則 B19 - Knapsack 2
  N個の品物がある。重さの合計がW以下になるようにしたときの価値の合計の最大値を求める。
  dp[見た個数][価値]=重量 としてdpテーブルを埋める。dp[N][i]<=Wとなるiの最大値が答え
}

bitDP{
  ABC041 D - 徒競走
  N匹のうさぎがいる。M人の観客がいる。i番目の観客によると、うさぎxiはうさぎyiよりも先にゴールした。すべての観客の情報に合致する着順が何通り考えられるか求める。
  トポロジカルソートの場合の数はbidDPをする。最初空の集合Sをdp=1とし、それに対して、1匹のうさぎを追加する。既に追加されていた場合はスキップし、更にこのうさぎより後にゴールしていなければいけないうさぎが含まれていたら何もしない。そのようなうさぎがいない場合、新たな集合Sに元の集合のパターン数を足し合わせる。最終的な答えはすべてのうさぎがゴールした集合。

  ABC142 E - Get Everything
  宝箱がN個ある。鍵がM個ある。鍵iはai円で、bi種類の宝箱ci1,...,cibiを開けられる。全ての宝箱を空ける為の最小費用を求める。不可能な場合は-1を出力する。
  鍵を開けられる宝箱の集合とコストの組で管理する。データ構造はmapでもvectorでも。集合を0から順にまわして、各集合で全種類の鍵を使ってみるbitDPをする。

  ABC180 E - Traveling Salesman among Aerial Cities
  3次元空間内にNこの都市がある。座標(a,b,c)から(p,q,r)に移動するコストは|p-a|+|q-b|+max(0,r-c)である。都市1からスタートし、全ての都市を1度以上巡って都市1に戻るまでの最小コストを求める。
  dp[これまで訪問した都市][これから行く都市]でbitDPをする。

  ABC190 E - Magical Ornament
  N種類の魔法石が流通している。魔法石を一列に並べて飾りを作る。隣り合わせにできる魔法石の組み合わせがM組与えられる。魔法石C1,,CKをそれぞれ1個以上含む魔法石の列を作るときの魔法石の個数の最小値を求める。作れない場合は-1を出力する。
  まずBFSでK種類の魔法石遷移のコストを求める。次にそのコストを使ってbitDPで巡回セールスマン問題を解く。

  ABC199 E - Permutation
  (1,2..N)を並び替えてできる数列aであって以下の条件を満たすものの数を求める。
  1<=i<=Mを満たす全ての整数iについて、a1..aXiの中にYi以下の数はZi個以下しか存在しない。
  
  ABC215 E - Chain Contestant
  N回のコンテストの種類が文字列Sで与えられる。出るコンテストを順番を保ったまま抜き出したとき、種類毎にひとかたまりになっているような選び方の総数を998244353で割った余りを求める。
  dp[文字数][今まで参加したコンテストの種類][直前に参加したコンテストの種類]でbitDPをする。

  ABC232 F - Simple Operations on Sequence
  長さNの整数列A,Bが与えられる。整数列Aに2つの操作のうちどちらかを行う事を好きな回数繰り返す。1.Aのひとつの要素をコストXで+1か-1する。2.隣り合うAの要素をコストYで交換する。AをBに一致させるためにかかる合計費用の最小値を求める。
  選択済みの文字列を集合で扱い、+-コストと入れ替えコストを加算していく。入れ替えコストの計算はppcllで転倒数を計算する。

  ABC278 F - Shiritori
  N個の文字列がある。先手と後手でこれらの文字列を用いてしりとりをする。どちらが勝つか判定する。
  使用済単語の集合、最後に使用した単語を用いてbitDPをする。遷移は1つでも負け盤面に遷移可能なら勝ち。

  ABC301 E - Pac-Takahashi
  H行W列のグリッドがある。グリッド上にはいくつかのお菓子が置かれている。スタートからゴールまでT回以内で移動するとき、回収できるお菓子の個数の最大値を求める。
  各頂点間の距離を求めて巡回セールスマン問題を解く。

  ABC310 F - Make 10 Again
  ;
  いくつか選んである出目の集合を達成できる

  EDPC O - Matching
  N人の男性とN人の女性がいる。それぞれの相性が良いか悪いかが与えられる。相性が良い男女同士のペアをN組作る方法は何通りか、10^9+7で割った余りを求める。
  rep(i,0,N) for(int s=0; s<(1<<N); ++s) rep(j,0,N)でbitDPをする。

  EDPC U - Grouping
  N羽のうさぎがいる。各うさぎ間には相性の点数がある。うさぎたちをいくつかのグループに分ける。グループ分け後に同一グループにいるなら得点を得る。得点の最大値を求める。
  あるうさぎで1つのグループを作ったときの点数を前計算する。求めるグループを部分集合に分けて、部分集合の最適値にグループに足りないものを1つの集合として加えたもので更新していく。

  鉄則 B23 - Traveling Salesman Problem
  巡回セールスマン問題、コード短縮あり。

  Donutsプロコンチャレンジ2014 E - お菓子やさん
  N店のお菓子屋さんを巡る。いくつかの店ではスタンプをカードに押してもらえる。店aiのスタンプを持って店biを訪問するとci個のお菓子が貰える。貰えるお菓子の最大値を求める。
  dp[訪問済みの店]=お菓子の最大数としてbitDPをする。
}

桁DP{
  ABC129 E - Sum Equals Xor
  正整数Lが二進数表記で与えられる。以下の条件を満たす非負整数a,bの組がいくつ存在するか求める。
  a+b<=L
  a+b=a XOR b
  理解していない

  ABC135 D - Digits Parade
  0-9,?で構成された文字列Sが与えられる。?を数字に置き換えてできる整数のうち、13で割って5余る数は何通りできるか、10^9+7で割った余りを求める。
  dp[][]をその桁で、その余りになるパターン数として桁DPをする。

  ABC154 E - Almost Everywhere Zero
  1以上N以下の整数であって、0でない数字がちょうどK個あるようなものの数を求める。
  桁数、0以外の個数、0:これまで採用した数字がNと同じ 1:N以下が確定としてdp[105][4][2]を作り、左の桁から桁DPをする。

  ABC155 E - Payment
  1,10,10^2,...,10^(10^100)の種類の紙幣がある。価値Nのものを買うときにN以上の金額を支払い、お釣りをもらう。自分と店員が使う紙幣のモ位数の最小値を求める。
  まだ説明を書けるほど理解できていない

  ABC317 F - Nim
  
  ABC336 E - Digit Sum Divisible
  ;
  ;
  
  EDPC S - Digit Sum
  1以上K以下の整数のうち、十進表記における各桁の数字の総和がDの倍数であるものは何個か、10^9+7で割った余りを求める。
  dp[dgt][d][isless]で桁DPをする。最後に0の1パターンを減じる。

  TDPC E - 数
  N以下の正整数であって各桁の和がDの倍数であるものの個数をmod1000000007で求めよ。
  dp(桁数)[isless][剰余]=パターン数 として桁DPをする。正整数なので最後に0を除くため-1する。
}

確率DP{
  ABC184 D - increment of coins
  袋の中に金銀銅貨がA,B,C枚入っている。袋の中からランダムに1枚取り出し、同じ種類の硬貨を2枚戻す操作をいずれかの硬貨が100枚になるまで繰り返すときの操作回数の期待値を求める。
  dp[i][j][k]=dp[i+1][j][k]*i/(i+j+k) + dp[i][j+1][k]*j/(i+j+k) + dp[i][j][k+1]*k/(i+j+k) + 1として、i,j,kが大きい方から求める。
}

期待値DP{
  ABC263 E - Sugoroku 3
  1からNまでのマスがある。はじめマス1にいる。マス1からN-1までにはそれぞれサイコロが置いてある各サイコロは0以上Ai以下の整数を等確率に出し、出た目の数だけ進む。ゴールに到着したときのサイコロを振る回数の期待値をmod998244353で求める。
  最後から期待値DPをする。累積和で高速化する。漸化式はE3=(1/4)*(E3+E4+E5+E6)+1のように立てられ、この例ではE3で整理して求められる。

  ABC266 E - Throwing the Die
  サイコロを使いNターンのゲームをする。サイコロを振りN回までなら振り直せる。最後に出た目をスコアとするとき、最適に行動したときのスコアの期待値を求める。
  最後から計算していく。最後一回の期待値は3.5。その前はその期待値未満の1,2,3は振り直し、4,5,6は終了する。その行動をする場合の期待値で更新する。これをN回シミュレートする。

  ABC280 E - Critical Hit
  体力Nのモンスターがいる確率Pで体力を2減らし、確率(1-P)で体力を1減らす。モンスターの体力が0以下になるまでの攻撃回数の期待値をmod998244353で求める。
  dp[i]=1+dp[i-2]*p+dp[i-2]*(1-p)を順番に計算する。

  ABC314 E - Roulettes
  N台のルーレットがある。i番目のルーレットにはPi個の整数が書かれておりCi円支払うことで1回プレイできる。支払う金額をなるべく小さくするように行動し、出目の合計がMを超えるようにプレイするとき、支払う金額の期待値を求める。
  dp[残りのポイント数]=金額の期待値 としてdpする。残りのポイントが決まれば選ぶべきルーレットが決まる。0の出目があるので数式を変形して考える事に注意。

  ABC350 E - Toward 0
  ;
  2から6までが出るまでのコストの期待値EはE=Y+1/6*Eを整理してE=6/5*Y
}

状態をまとめるDP{
  ABC232 E - Rook Path
  H×Wのマスがある。(x1,y1)にルークが置かれており、行または列が同じマスにルークを移動させることをK回繰り返す。但し、前回と同じマスは選べない。K回の操作の後(x2,y2)に置かれているようにする方法は何通りか、998244353で割った余りを求める。
  目的のマス、行だけが同じマス、列だけが同じマス、両方異なるマスをそれぞれ1つの状態としてDPをする。
}

木DP{
  ABC036 D - 塗り絵
  N個の島があり、N-1個の橋がある。どの島からどの島へも到達できる。島を白または黒に塗る。ただし、両端の島が黒で塗られているような橋があってはならない。色の塗り方が何通りあるか、10^9+7で割った余りを求める。
  自分が白の時子は白or黒となり、自分が黒の時子は白となる。子供同士のパターン数を掛け合わせて、自分が白の時黒の時のパターン数をそれぞれ計算できる。根からDFSをスタートする事で葉からパターン数を求めていく。

  ABC259 F - Select Edges
  N頂点の重み付きの木が与えられる。N-1本の辺のうちいくつかを選ぶ事を考える。但し、頂点iに接続する辺はdi本までしか選べない。辺の重みの総和の最大値を求める。
  葉から順番に、親への辺の残しても良い、残さないの2通りで最大値を求めていく。

  ARC028 C - 高橋王国の分割統治
  木がある。ある1つの頂点を除いた際の連結成分のサイズの最大値を各頂点について求める。
  ある頂点を根としてdfsをして各頂点を親とした部分木のサイズを求める。ある頂点の部分木のサイズは子の部分木のサイズの合計。ある頂点を除いた際の連結成分のサイズの最大値は、子側は全ての子の部分木を見る、親側は(N-自分の部分木のサイズ)を見る。これらの最大値が答え。

  AGC009 B - Tournament
  N人が大会に出場した。このN人でトーナメント形式でN-1回の試合を行った。1番が優勝し、他の人が誰に負けたかの情報が与えられる。トーナメントの深さの最小値を求める。


  EDPC P - Independent Set
  N頂点の木がある。各頂点を白黒に塗分ける方法であって、隣り合う頂点同士をともに黒で塗らない組み合わせが何通りか、10^9+7で割った余りを求める。
  木の根を決め、各頂点を白、黒にするパターン数dfsの戻り掛け順で子から求めていく。ある頂点を白にするなら子はなんでもよく、黒にするならすべて白にする必要がある。それぞれの子のパターン数を掛け合わせて求めていく。
}

全方位木DP{
  ABC160 F - Distributing Integers
  N頂点の木がある。まず頂点kに1を書く。数字を記入済みの頂点に隣接している頂点に2から順番に番号を書く。書き方の場合の数を10^9+7で割った余りを求める。これを各kに対して求める。
  木DPパートでは各子の部分木のパターン数の総積に割り当て方のパターン数を掛け合わせる。これを全方位木DPする。
}

区間DP{
  ABC217 F - Make Pair
  2N人の生徒が並んでいる。どの2人も互いに仲が良いか悪いかの関係が与えられる。隣り合う仲の良い2人を選んで列から抜く操作をN回繰り返すとき、N回の操作方法としてあり得るものを998244353で割った余りを求める。
  まだ理解できていない

  EDPC L - Deque
  太郎と次郎がゲームで勝負する。数列aが与えられ、太郎の先手でaの先頭か末尾を取り除き、その値が点数となる。各人が最適に行動した場合のゲーム終了時の太郎の得点-次郎の得点を求める。
  dp[l][r]:[l,r)の盤面で開始した場合の最終点数とする。区間が短い方から更新し、dp[0][N]が答え。

  EDPC N - Slimes
  N匹のスライムが横一列に並んでいる。左右に隣り合う2匹を合体させるとそれぞれの大きさの和のコストがかかる。全て合体させる時のコストの最小値を求める。
  区間dpをする。区間dpなので半開区間で管理すると、結合を書きやすい。

  鉄則 B21 - Longest Subpalindrome
  文字列Sから文字を取り除いて作れる回文の最長の長さを求める。
  dp[l][r]=長さ として求める。遷移はS[l]==S[r]ならdp[l][r]=dp[l+1][r-1]+2、違うならdp[l][r]=max(dp[l+1][r],dp[l][r-1])
}

括弧の問題{
  ABC064 D - Insertion
  辞書順で最初の括弧の組み合わせが正しい文字列を求める
  '('が出たら+、')'が出たら-していく

  ABC167 F - Bracket Sequencing
  N個の文字列Sが与えられる。これらを好きな順で連結するとき括弧列を構成出来るか判定する。
  各Sの内部を消滅させると")("の並びのみになる。次の優先順位で連結する。'('-')'が非負のものを')'が少ない順に、'('-')'が正のものを'('が多い順に。

  ARC170 A - Yet Another AB Problem
  'A','B'からなら長さNの文字列S,Tがある。次の操作を繰り返してSをTに一致できるか判定し、可能な場合は最小の操作回数を求める。操作は、i<jを満たすi,jを選びSiを'A'でSjを'B'で置き換える。
  'A'に置き換えたいものを'('、'B'に置き換えたいものを')'として括弧列を作る。答えは合っている括弧列のペア数+処理できなかった括弧の個数。但し、左から見てTに'B'しか出ていないのにSに'A'が出たり、右から見てTに'A'しか出ていないのにSに'B'が出たりして場合は達成不可。

  天下一プログラマーコンテスト2015予選B B. 天下一リテラル
  与えられた文字列が集合型か辞書型のどちらか判別する。
  '{'は+'}'は-していき、1の時に:が出たら辞書型と判別する。
}

全探索{
  ABC075 D - Axis-Parallel Rectangle
  2次元座標上にN個の点がある。長方形の内部にK個以上の点を含みつつ、各辺がX軸かY軸に平行な長方形の内、最小の面積を求める。
  各点のx,y座標をsetに格納し、左下のx,y座標、右上のx,y座標を決める、4重ループを回す。
}

bit全探索{
  ABC080 C - Shopping Street
  商店街に店を構える。他の店と営業時間が被る数で利益が決まる。利益の最大値を求める。
  bit全探索で全営業時間パターンを調べる。他店との営業時間の被りの数はppcllで数える。

  ABC100 D - Patisserie ABC
  N種類のケーキがある。各種類は「綺麗さ」「おいしさ」「人気度」の値がある。値は0以下の場合もある。この中からM種類を選ぶときの(綺麗さの合計の絶対値)+(おいしさの合計の絶対値)+(人気度の合計の絶対値)の最大値を求める。
  3つの値のプラス、マイナスの組み合わせを全探索する。
  
  ABC104 C - All Green
  1以上D以下のそれぞれの整数iに対して、100i点を付けられた問題がpi問存在する。あるiの問題を全て解答するとそれぞれのiについて定められたコンプリートボーナスが得られる。総合スコアをG点以上にするために解く必要がある最小の問題数を求める。
  コンプリートボーナスを取る組み合わせをbit全探索して、答えを求める。

  ABC128 C - Switches
  電球とスイッチの組み合わせをbit全探索で決める
  
  ABC159 E - Dividing Chocolate
  グリッドに区切られたチョコレートがある、各グリッドはチョコレートまたはホワイトチョコレートである。チョコレートを縦または横に一直線に分割する操作を何度か行い、分割後のどのブロックにもホワイトチョコレートのマスがKマス以下にする。最小で何回分割する必要があるか求める。
  行方向は最大で10行なので、こちらの方向の分割方法をbit全探索する。分割したら行ごとにグループ化して、貪欲法で列方向の分割回数を求める。

  ABC167 C - Skill Up
  N冊の参考書をいくつか買ってM個のアルゴリズムの理解度をX以上にする。購入額の最小値を求める。

  ABC173 C - H and V
  マス目の塗りつぶし方をbit全探索で決める

  ABC182 C - To 3
  3で割り切れる数字のパターンをbit全探索で列挙する

  ABC200 D - Happy Birthday! 2
  N個の正整数からなる数列Aが与えられる。mod200の合計値が等しくなるAの部分列B,Cを作れるか判定し、作れるならそれぞれ出力する。
  鳩ノ巣原理から、N>=8で225通りなのでN=8まででbit全探索する。

  ABC219 E - Moat
  xy平面上にいくつかの村がある。すべての村を囲むようなお堀を建設する。区画が4*4行列あり、村がある場合は区画の中心にあり、堀は区画の辺に建設する。堀の内部に全ての村を含むとき、お堀として考えられるものが何通りあるか求める。
  各区画がお堀の内部か外部かの2^16をbit全探索する。すべての村がお堀の内側にあるか判定し、お堀の内側が1つの領域で且つお堀内に穴が空いていないことを判定するために、4*4の周囲に区画を追加した6*6の領域を考えて、Union-Findでお堀の内側か外側かグループ分けする。グループ数が2なら条件を満たす。

  ARC007 C - 節約生活
  衛星放送には無料で見られる時間がある。テレビを付けてから無料で見られるパターンが与えられるので、最低何台のテレビがあれば常に無料で視聴可能か求める。
  視聴可能パターンをシフトしてorを取り、全時間視聴可能な中で必要台数が最も少ないものを求める。
}

ビット演算{
  ABC258 G - Triangle
  単純無向グラフが与えられる。頂点の組(i,j,k)のうち全ての頂点間に辺が存在するものの数を求める。
  間に辺のある(i,j)を選択する。i,jのどちらからも接続されたkの個数を(Ai&Aj).countで求めて全ての(i,j)で足し合わせたものが答え。
}

UnionFind{
  ABC040 D - 道路の老朽化対策について
  N個の都市とM本の道がある。各道はyi年に造られた。Q人の国民がおり、それぞれ都市vjに住みwj年以前に造られた道を使わない。各国民が行き来できる都市の個数を求める。
  年数で国民をクエリソートしてUnionFindで求める。

  ABC049 D - 連結
  N個の都市があり、K本の道路とL本の鉄道がある。全ての都市についてその都市と道路・鉄道のどちらでも連結している都市の数を求める。
  UnionFindで道路・鉄道別に連結成分に分解する。各都市毎に道路・鉄道のグループの組み合わせ毎の個数をカウント。最後に各都市毎に自分と同じ組み合わせのものがいくつあるか出力する。

  ABC120 D - Decayed Bridges
  N個の島とM本の橋がある。橋は2つの島を繋いでおり、双方向に移動できる。いくつかの橋を渡って行き来できなくなった2つの島の組の数を不便さと呼ぶ。橋が順番に崩落するとき、i番目の橋が崩落した直後の不便さを求める。
  橋を崩落と逆順に建設する。最初の不便さはNC2(N個から2個選んだ場合の数)。橋が建設されると橋の両端の島がまだ行き来できない場合、不便さは建設前の一方のグループ数*もう一方のグループ数だけ減少するのでUniou-Findで連結状態を管理して順番に求めていく。

  ABC126 E - 1 or 2
  N枚のカードが一列に伏せられており、各カードは1または2が書かれている。
  i=1...MについてAXi+AYi+Ziは偶数であることが分かっている。
  コストを1払うと1枚の数字を知る事が出来る。
  最小何コストで全てのカードの数字が分かるか求める。
  M個の事実をUnionFindでグループ化し、グループの中の1枚が分かればすべて分かるので、グループの数が答え。

  ABC157 D - Friend Suggestions
  SNSにN人が登録しており、友達関係とブロック関係が与えられる。各人について友達候補の人数を求める。友達候補とは、友達を辿って行けて、直接の友達でなく、ブロック関係でもない人の事である。
  友人関係をすべてUFで繋ぐ。各人で友人関係の人数から自分と直接の友人を減じて、友人関係且つブロック関係を減じたものが答え。

  ABC177 D - Friends
  友人関係をUFで整理して、友人のいないグループ分けをする。最大グループの人数が答え

  ABC183 F - Confluence
  N人の生徒が登校する。生徒iはクラスCiに属する。Q個のクエリを順番に処理する。クエリは2種類ある。
  1:生徒aを含む集団とbを含む集団を合流する。
  2:クエリの時点で既に生徒xと合流している生徒のうちクラスyに属する生徒の数を求める。
  UnionFindで生徒の集合を管理する。UnionFindの中にmapを作り、根でそのグループの生徒の各クラス属する人数を管理する。
  
  ABC206 D - KAIBUNsyo
  文字列を何回の操作で回文にできるか求める

  ABC214 D - Sum of Maximum Weights
  N頂点の木があり、各辺の重みが与えられる。異なる頂点u,vまでの最短パスに含まれる辺の重みの最大値を全ての頂点の組み合わせについて求め、合計したものを答える。
  辺の重みが小さい方から連結して、重み*パターン数を足し合わせていく。

  ARC027 B - 大事な数なのでZ回書きまLた。
  10進数の正の整数がある。そのいくつかがアルファベットになった2つの文字列がある。元の数字としてあり得るパターン数を求める。
  桁ごとにUnionFindで連結させる。数字が連結している場合は1通り、先頭は9通り、それ以外は10通りをかけていく。

  ARC056 B - 駐車場
  駐車場でN人が車を駐めようとしている。それぞれの駐車場を結ぶM本の道がある。i番目の人はi番目の駐車スペースに車をとめる。駐車済みの駐車場には入れない。1番目からN番目まで順番に駐車場にやってくるとき、とめられる人の番号を昇順に出力する。
  番号の大きい人から、自分より番号の大きい駐車場とUnionFindで連結した後、止められるか判定する。

  ARC097 D - Equals
  1からNまでの整数を並べ替えた順列pがある。また、1以上N以下の整数のペアがM個与えられる。M個の任意のペアを使って順列pの2つの要素交換する操作を好きなだけ行い、pi=iとなるiの数の最大値を求める。
  UnionFindで数字を移動できる領域を作る。piがiに移動できる領域に入っているか1つずつ確認する。

  ARC107 C - Shuffle Permutation
  N×Nの行列と整数Kが与えられる。行列の要素は1,2...N^2のいずれかをちょうど1つずつ含む。以下の2種類の操作を好きな順序で好きな回数行える。
  操作1:2つの列を選び、各行同士の2つの数の和がK以下ならば入れ替える。
  操作2:2つの行を選び、各列同士の2つの数の和がK以下ならば入れ替える。
  最終的に得られる行列のパターン数を998244353で割った余りを求める。
  行、列別に入れ替え可能なものをUnionFindでグループ化して、行、列のパターン数を掛け合わせたものが答え。

  ARC108 C - Keep Graph Connected
  N頂点M辺の連結な無向グラフが与えられる。多重辺は存在し得るが自己ループはない。各辺にはラベルciが付いている。各頂点に整数を付け、それぞれの辺について辺の両端の頂点の片方のみと同じ整数を持つ辺のみを残して辺を取り除く操作の後もグラフが連結であるような整数の書き方が存在するか判定し、存在するならその一例を示す。
  UnionFindで辺の集合を全域木に落とす。根からdfsをして条件を満たす番号を付けていく。

  ARC111 B - Reversible Cards
  両面に正整数の書かれたN枚のカードがある。片方はaiもう片方はbiである。各カードの向きを自由に選び、表側の数字の種類の最大値を求める。
  数字を頂点、カードの整数の組を辺とみなして連結成分毎に、木かループを持つかを判定する。木なら(頂点数-1)種類。ループを持つなら頂点数種類を達成できる。

  ARC114 B - Special Subsets
  1以上N以下の整数全てから成る集合をSとする。
  fはSからSへの関数であり、Sの各要素に対するfの値が与えられる。
  Sの空でない部分集合Tで、
  1.全てのTに属するaについてf(a)もTに属する
  2.全てのTに属するa,bについてa!=bならf(a)!=f(b)
  答えはサイクル数をCとして、2^C - 1。UnionFindでグループ数を求める。問題の制約からグループ数がサイクル数になっている。

  ARC151 B - A < AP
  順列Pが与えられる。次の2条件をともに満たす長さNの整数列Aの個数を998244353で割った余りを求める。条件1:Aの各要素は1<=Ai<=M,条件2:整数列Aは整数列(AP1,..,APN)より辞書順で小さい。
  先頭i桁より前が一致している状況からi桁目で辞書順を確定させる事を考える。functional graphを作り、依存関係を作る。先頭から各桁を対象にパターン数を計算する際にunion-findでfunctional graphに従い要素を結合する。結合済みならスキップ。今見ているAiとAPiの組み合わせはMC2通り、それに自由に組み合わせられるものをCとしてM^Cを掛け合わせる。Cはunion-findのグループ数-1。

  ARC164 B - Switching Travel
  単純、連結な無向グラフがある。各頂点は白または黒に塗られている。好きな頂点から出発し、隣接する頂点のうち今いる頂点と異なる色の頂点に進む。進む際、元いた頂点の色を反転させる。出発点に戻れるようなものが存在するか判定する。
  異なる色の頂点のみを結合する。その後同じ色を結ぶ頂点ペアを見てそれらが連結なら達成可能。

  典型90 012 - Red Painting（★4）
  白いマス目が与えられる。クエリ1なら指定されたマスを赤く塗る。クエリ2なら指定の2マスを上下左右移動で赤のみを通って到達できるか判定する。
  連結しているかUnionFindで求める。

  エイシング プログラミング コンテスト 2019 C - Alternating Path
  H行W列のマス目があり、各マスは黒か白に塗られている。黒ますc1と白マスc2の組で、白黒交互に到達可能なものの個数を求める。
  到達可能なマスのグループをUnionFindで求める。各グループの白黒のマスの数をそれぞれ求め、グループ毎に白黒の積を求めて足し合わせる。

  ACL Contest 1 A - Reachable Towns
  2次元平面上にN個の街がある。各x,y座標(x1,x2,..,xN),(y1,y2,..,yN)はともに(1,2,..,N)の順列である。x,yがともに小さいかともに大きい街との間で移動可能である。各街について行き来可能な街の数を答える。
  xの昇順にソートする。登場済みの街の各集合の内y座標が最小のものをmin_priority_queueで管理する。新たに追加されるy座標は今入っている中で最小のものに統合される。

  AtCoderPetrozavodsk Contest001 D - Forest
  N頂点M辺の森が与えられる。各頂点には値Aiが与えられている。頂点を2つ選択してコストAi+Ajで辺を引く。森を木にするための最小コストを求める。達成不可ならImpossibleを出力する。
  各木から1つは選択する必要がある。その他は小さい順に選択可能。コーナーケースとして、最初から連結なら答えは0、連結にするための頂点が足りなければImpossible。

  CODE FESTIVAL 2016 Final C - Interpretation
  M種類の言語があり、N人の人がいる。各人はKi種類の言語を話せる。2人の両方が話せる言語があるか、ある人Xが存在して2人ともがXとコミュニケーションを取れる場合に2人がコミュニケーションを取れる。N人全てがコミュニケーションを取れるか判定する。
  人と言語を要素としてUnionFindを構築する。判定は人0が全ての人と同一グループか見る。

  鉄則 B66 - Typhoon
  N個の駅とM本の路線がある。2種類のクエリを順に処理する。1:x本目の路線が運休になる,2:駅sから駅tに移動可能か答える。
  まずクエリ終了時点の連結状態を作る。その後クエリを逆順に処理する。
}

二部グラフ{
  ABC131 F - Must Be Rectangular!
  2次元平面上にN個の点がある。3点選んでx,y軸に平行な長方形を描けるとき残りの1点を追加する事を出来る限り行う。但し既に点が存在するなら追加しない。追加できる点の個数を求める。
  各点をx,yで分解した頂点にし、x,yの間に辺を張った二部グラフを作る。この問題の操作では連結成分ごとに完全二部グラフになるまで辺を追加できるのでその辺数を求め、Nを減じたものが答え。

  AGC039 B - Graph Partition
  連結無向グラフがある。頂点全体を以下の条件を満たす空でない集合に分解可能か判定する。可能な場合集合の最大個数を求める。
  条件：どの辺も、番号が隣り合う頂点集合の頂点どうしを結ぶ。
  二部グラフか判定する。二部グラフでなければ達成不可能。二部グラフの場合、ワーシャルフロイドで一般グラフの直径を求める。答えは直径+1。

  CODE FESTIVAL2017qualB C - 3 Steps
  N頂点M辺の連結無向グラフがある。頂点uから辺をちょうど3本辿ることによって頂点vに辿り着けるようなu,vの間に辺を追加する操作を最大何回行えるか求める。但し、既に辺が存在する場合は追加しない。
  最終状態を考える。二部グラフの場合、異なる色同士の頂点間に辺が張られる。二部グラフでない場合、完全グラフになる。それらの辺数からMを減じたものが最大の操作回数。
}

数え上げ{
  ABC066 D - 11
  1,..,Nの整数からなる長さN+1の数列がある。各数は1回以上現れる。k=1,..,N+1のそれぞれについて、長さkの連続とは限らない部分列の個数を10^9+7で割った余りを求める。
  ダブる数の2つのインデックスを求める。k個を選ぶ組み合わせの数から、ダブる数から1つと、ダブる数の間以外の数からのみ選ぶパターン数を減じる。

  ABC127 E - Cell Distance
  N行M列のマス目があり、そのうちKマスに駒を1つずつ置く。駒の配置を決めた後、各駒の組み合わせでマンハッタン距離の総和を取った値をコストと呼ぶ。駒の全ての配置のコストの総和を10^9+7で割った余りを出力する。
  x,yは分離して考えられる。ある2つの駒に注目し、x座標の差分を1からM-1までまわす。差分1は横方向のM-1通りの場所に現れ、差分2はM-2通りの位置に現れていく。また2つの駒の縦方向の位置はN*N通りなのでそれぞれ掛けて足し合わせる。これをy方向にも足し合わせる。それに他の駒の配置である(N*M-2)C(K-2)を掛け合わせたものが答え。

  ABC152 D - Handstand 2
  N以下の数同士で先頭と末尾を入れ替えた組み合わせがいくつできるか数える
  各パターンの出現回数をmap<P,int>で集計してab,baをかけ合わせる

  ABC170 D - Not Divisible
  数列が与えられ、他の何れの要素でも割り切れない要素の数を求める
  エラトステネスの篩のように倍数をチェックしていく
  篩を作って検証するか、ソートして篩を作りながら検証する。後者の方が計算量は少ない

  ARC113 D - Sky Reflector
  縦Nマス横Mマスのマス目に1以上K以下の整数を書く。列Aを各行の最小値を並べたもの、列Bを各列の最大値を並べたものと定義する。列対(A,B)の個数を998244353で割った余りを求める。
  行と列の数は入れ替えて良い。M<=Nとして考える。max(A)<=min(B)であるので、A,Bの境界を全探索する。Aの側は境界となる値が少なくとも1つは含まれるように数えたいので、i^+-(i-1)^Nとする。Bの側はM=1のとき1パターン、M>1のとき(K-i+1)^Mパターン。A,Bに対するものを掛けて足し合わせる。

  ARC116 B - Products of Min-Max
  整数列の空でない部分列のmax*minの総和を求める
  ソートしてから考える

  HHKB プログラミングコンテスト 2020 E - Lamps
  H行W列のマス目があり、各マスは散らかっているかそうでないかのどちらかである。これらの内0個以上の散らかっていないマスに照明を置く。照明は散らかっているマスにぶつかるまで上下左右に照らせる。あり得る照明の置き方毎に照らされるマスの数を合計した総和を10^9+7で割った余りを求める。
  照明の置き方の全パターンから、各マスが照らされないパターン数を減じる。(自力ACは照らされるパターン数を求めた)
}

数え上げ(greedyからの帰着){
  ABC171 F - Strivore
  「好きな英小文字1文字を好きな位置に挿入する」という操作を文字列Sに丁度K回繰り返してできる文字列が何通りあるか、10^9+7で割った余りを求める。
  重複なく数え上げる考え方は、部分文字列としてSを含むか。先頭からgreedyに文字列Sを取ったときに最後にrest文字余る組み合わせを求める。restが違えば異なる文字列になるので、restを全通り回す。
}

貪欲法{
  ABC091 C - 2D Plane 2N Points
  二次元平面に赤と青の点がN個ずつある。赤い点のx,y座標がそれぞれ青い点より小さい場合仲良しペアになれる。仲良しペアの最大数を求める。
  青い点をx座標が小さい方から見る。ペアにできる赤い点があれば、そのうち最もy座標が大きいものを使っていくと答えが求まる。
  
  ABC102 D - Equal Cut
  長さNの整数列Aがある。Aを4つの空でない連続する部分列B,C,D,Eに分解する。それぞれ総和を求めて、最大値と最小値の差の絶対値の最小値を求める。
  真ん中の区切り位置を全探索する。その左側、右側はそれぞれ独立に貪欲に中心を決定できる。それを二分探索でO(logN)、または尺取り法でO(1)で求める。

  ABC137 D - Summer Vacation
  N件の日雇いアルバイトがある。i件目のアルバイトはAi日後に報酬Biが得られる。1日に1件まで選べて、請けたことのあるアルバイトは再び選べない。M日後に得られる報酬の合計の最大値を求める。
  最終日から請けられるアルバイトのうち最大の報酬のものを貪欲に足していく。

  ABC149 D - Prediction and Restriction
  「じゃんけんバトル」というゲームをする。N回じゃんけんを行う。グー、チョキ、パーで勝った時R,S,P点獲得する。ちょうどK回前に出した手は出せない。ゲームの出す手は分かっている。最大で合計何点獲得できるか求める。
  先頭から貪欲に勝つ事にする。出した手を記憶しておき、K回前に同じ手なら負ける事にする。

  ABC173 E - Multiplication 4
  N個の整数が与えられる。この中からちょうどK個選ぶとき、積の最大値を10^9+7で割った余りを求める。
  答えを正にできるか判定し、できないなら絶対値が小さい順に貪欲に取る。できるなら、正負それぞれ2個セットにたものを合わせて大きい方から貪欲に取る。

  ARC127 A - Leading 1s
  f(x)をxを10進表記したときに先頭に並ぶ1の個数とする。Nが与えられるので、f(1)+...+f(N)を求める。頂点をシフトして、各頂点で答えを求める。
  1,2 11,12 111,112の後ろに0を繋げたものを作り、左の数以上、右の数未満でN以下のものを足し合わせていく。
}

登場回数をmapで管理{
  ABC053 D - Card Eater
  奇数枚のカードの山から3枚選び、最大最小のカードを食べ残りを山に戻す。残せるコードの最大枚数を求める
  それぞれのカードの枚数をmapでカウントする。偶数枚の数が奇数種類なら種類数から1引いたものが答え

  ABC111 C - /\/\/\/
  与えられた数列の偶数番目、奇数番目をそれぞれすべて同じ数にしたい。変更する要素の最小値を求める。但し偶数番目、奇数番目を同じ数字にしてはいけない。
  mapで登場回数をカウントし、vector<pair<int,int>>に格納しソート

  ABC114 D - 756
  N!の約数のうち約数をちょうど75個持つ正の整数は何個あるか求める。
  管理はvectorでやったが、解説はmapだった。素因数分解して条件を満たす約数の個数の組み合わせを求める。

  ABC159 D - Banned K
  数字が書かれたN個のボールのk番目を除いたとき、書かれた数字が等しい2つの取り出し方の数をすべてのkで求める
  全パターンの合計を求め、そこからある場合のパターン数を引く

  ABC171 D - Replacing
  数列の値Bをすべて値Cに置き換える処理をQ回行う。各操作後の数列の総和を求める。
  登場回数をmapで管理し、合計から足し引きする。

  ABC181 D - Hachi
  1から9の数字からなる数字列Sが与えられる。Sを並び変えて8の倍数を作れるか判定する。
  mapではない。1桁なら8かどうか、2桁なら前後入れ替えで達成できるか調査、3桁以上は登場回数を0を含めてvectorで管理し3桁の8の倍数を作れるだけの数字があるか調べる。

  ABC197 E - Traveler
  数直線上に1からNまでのN個のボールがある。各ボールには1以上N以下の整数で表される色がついている。
  座標0から毎秒1の速さで数直線上を動き、全てのボールを回収してから0に戻る。
  このとき色を回収順に広義単調増加にする。ボールは回収できるときに必ずしも回収する必要はない。かかる時間の最小値を求める。
  (登場回数を管理するわけではない)色ごとに最小最大の座標を求めておき、色の小さい順に左端右端で終わる最小時間を求めていく。

  ABC206 C - Swappable
  配列から2つ選んだ時、2つが異なる組み合わせを求める
  全パターンの合計を求め、そこからある場合のパターン数を引く
}

マンハッタン距離{
  ABC102 C - Linear Approximation
  abs(A1-(b+1))+abs(A2-(b+2))+...+abs(AN-(b+N))を最小化するbを自由に選び、最小値を出力する。
  マンハッタン距離の差の総和を最小化するときは中央値を使う(この問題は数直線上だが同じ手法で解く)

  ABC112C - Pyramid
  数点のx,y座標と高さが与えられる。ピラミッドの中心座標と高さを求める。
  中心位置を仮定して高さを求め、その高さが全ての点で満たすかチェックする。中心位置を全探索する。

  ABC178 E - Dist Max
  二点間のマンハッタン距離の最大値を求める。a=x+y,b=x-yの45度座標を使う。

  典型90 036 - Max Manhattan Distance（★5）
  二次元平面状にN個の点がある。Q個のクエリで点の番号が与えられるので、他の点とのマンハッタン距離の最大値を出力する。
  a=x+y,b=x-yの45度座標を使う。

  典型90 070 - Plant Planning（★4）
  N棟の工場があり、どこかに1つ発電所を建てる。発電所から各工場までのマンハッタン距離の総和の最小値を求める。
  X,Y別々に中央値を求めて、そこからの距離を足し合わせる。
}

modint{
  ABC145 D - Knight
  modint組み合わせの問題、sunukeさんのcombを使用

  ABC156 D - Bouquet
  modintで全パターンの2^nを繰り返し二乗法で求め、特定パターンを減じる

  ARC111 A - Simple Math 2
  floor((10^N)/M)をMで割った余りを求める。
  10^Nを10^NからM^2を任意の回数減じたものに置き換えても答えは同じになるので、10^Nを(modM^2)で繰り返し二乗法で求めて計算する。
}

数学{
  ABC057 C - Digits in Multiplication
  Nが与えられる。N=A*Bを満たすA,Bの桁数大きい方の最小値を求める
  1からルートNまで探索する

  ABC142 D - Disjoint Set of Common Divisors
  AとBの2つの数の公約数からどの組み合わせも素になるように選ぶ。最大いくつ選べるか
  AとBの最大公約数を素因数分解する

  ABC152 E - Flatten
  N個の正整数A1,A2...が与えられる。任意のi,jでAiBi=AjBjが成り立つBについて、Bの和の最小値を求める。
  すべてのAの最小公倍数を求め、それを各Aで割ったものの和が答え。但し、最小公倍数を求める時にAx*Ay/gcdは積の部分でオーバーフローするので、すべてのAを素因数分解してから掛け合わせて求める。

  ABC169 D - Div Game
  Nを素因数分解した結果から答えを導出

  ABC254 F - Rectangle GCD
  長さNの整数数列A,Bが与えられる。N*Nのマス目がある。マス(i,j)にはAi+Bjが書かれている。次のクエリをQ個処理する。h1,h2,w1,w2の矩形領域に含まれる整数の最大公約数を求める。
  GCDは引き算が可能。行に注目すると右のマスから左のマスを減じるとBの要素のみが残り、列で同様に考えるとAの要素のみが残り、A,Bを分離できる。ある矩形領域についてGCDを求めるとき、左上は残るがそこから右、下へはセグ木を使えばまとめて計算可能。また適切に足し引きする事でそれ以外の要素は0にすることが可能。

  ARC110 A - Redundant Redundancy
  2,3..,Nのどれで割っても1余るN以上10^13以下の整数を1つ出力する。
  2,3..,Nの最小公倍数に1加えたものが答え。

  ARC124 C - LCM of GCDs
  赤い袋と青い袋とN個のカードパックがある。カードパックには2枚の数字の書かれたカードが入っている。各カードパックについて一方のカードを赤い袋に、もう一方を青い袋に入れる。それぞれの袋に入った整数全体の最大公約数同士の最小公倍数が得点となる。得点の最大値を求める。
  1つ目のカードパックの2枚のカードの約数をそれぞれ求め、最大公約数を約数にできるか判定する。できる場合は最小公倍数を求めて、最大値を更新する。

  ARC159 B - GCD Subtraction
  変数a,bがあり、始めa=A,b=Bである。a,bがともに1以上の間、次の操作を繰り返す。a,bの最大公約数をgとする。a,bをそれぞれa-g,b-gに置き換える。操作回数を求める。
  操作はa,bをgで割り、1を減じる操作と等価。gが1以外になる最小の減じる回数を求めて操作を一括で行いたい。gの候補はa-bの約数に限られるので、各候補でaを割った余りを求め、その最小値が減じる回数の最小値。この操作を繰り返す。

  AGC018 A - Getting Difference
  箱にN個のボールが入っており、それぞれのボールには整数Aiが書かれている。箱から2つのボールを取り出し、数字の差の絶対値を書いたボールと元のボールを箱に戻す操作を好きなだけ行う事で、Kと書かれたボールを箱に入れられるか判定する。
  すべてのAの最大公約数をGとする。KがGで割り切れるM以下の整数であれば達成可能。

  典型90 030 - K Factors（★5）
  2以上N以下の整数のうち、K種類以上の素因数を持つものの個数を求める。
  素因数列挙の計算量はO(N log log N)である。2からNまで素数の倍数であるものをインクリメントした後、条件を満たすものをカウントする。

  典型90 085 - Multiplication 085（★4）
  正の整数Kが与えられる。abc=K(a<=b<=c)を満たす組がいくつあるか求める。
  約数を求めて全探索する。ただし、1<=K<=10^12でa*bはオーバーフローするので気を付ける。
}

XOR{
  ABC308 G - Minimum Xor Pair Query
  次の3種類のクエリを処理する。1:黒板にxを1つ書き込む、2:xを1つ消去する、3:黒板に書かれた2つの整数のXORの最小値を出力する。
  任意の非負整数x<y<zに対して、min(x^y,y^z)<x^zが成り立つ。つまり本問題では、隣り合う2数のXORのみがクエリ3の候補になる。multiset2つで黒板に書かれた数と答えの候補を管理する。
}

期待値{
  ABC008 C - コイン
  裏表が区別できるN枚のコインがある。コインの大きさは異なり、それぞれのコインには1つずつ正の整数が書かれている。これらのコインを無作為に並べ、すべて表向きにし、左端のコインから順に現在見ているコインより右側にあるコインの内現在見ているコインに書かれている整数の倍数が書かれているコインすべての裏表を反転する。この操作の終了時に表を向いているコインの枚数の期待値を求める。
  解説は後で書く。
  
  ABC078 C - HSI
  高橋君はプログラミングコンテストでYES,NOで答える問題でTLEした。全部でNケースでそのうちMケースてTLEしていた。Mケースでは実行に1900msかけて1/2の確率で正解し、残りN-Mケースで100msで必ず正解するプログラムに書き換えた。全て正解するまで再提出を繰り返すときの実行時間の総和の期待値を求める。
  確率pで発生する事象の発生までの試行回数の期待値は1/pである。1回あたりの実行時間と試行回数の期待値を求めて掛け合わせたものが答え。

  ABC194 D - Journey
  N個の頂点があり、頂点1にいる。1/Nの確率で1つの頂点を選ぶ。全ての頂点を選んだときの選択回数の期待値を求める。
  期待値=1/Pをすべての新しい数が出てくる事象に適応して合計を求める

  AGC049 A - Erasing Vertices
  N頂点からなる有向グラフがある。自己ループや多重辺はない。未削除のグラフの頂点をランダムに1つ選択し、到達可能な全ての頂点と辺を削除する。操作回数の期待値を求める。
  期待値の線形性により、求めるものはグラフが空になるまでにその頂点を選択する確率の総和に等しい。ある頂点が選択される確率は、その頂点を削除できる頂点数を|S(v)|としたとき、1/|S(v)|に等しい。これらの総和が答え。
}

データ構造{
  ABC127 D - Integer Cards
  カードの数字を書き換えて合計値を最大化する
  元々の数字と書き換え可能な数字を(数字,回数)のペアで全て一緒にし、大きい方からN個選ぶ
  初回はクエリソートで解いた

  ABC141 D - Powerful Discount Tickets
  品物の価格を1/2にする割引券を使って合計金額を最小化する
  割引券を高価な品物に使うためpriority_queueで最大値を高速に取り出す

  ABC158 D - String Formation
  文字列Sが与えられる。クエリ1はSを前後反転、クエリ2は先頭または末尾に1文字追加する。Q回のクエリ後の文字列を求める。
  dequeを使って解く。クエリ1はやったふりをする。

  ABC203 E - White Pawn
  Nを正の整数とする。行と列にそれぞれ0から2Nまでの番号が付いたマス目がある。白のポーンが(0,N)に置かれている。黒のポーンはM個ある。以下の移動が可能。
  1.下に黒ポーンがなければ下に移動
  2.斜め下に黒ポーンがあればそこに移動
  最下段の何か所に到達可能か、個数を求める。
  map<int,vi>で段ごとに黒ポーンの位置を受け取る。まずsetに初期位置を格納する。その後、段ごとに斜め移動可能な場所を求めてviに格納し、黒ポーンの上のものを削除し、viからsetに追加する。最終的なsetのサイズが答え。

  ABC213 C - Reorder Cards
  格子にカードが置かれており、それぞれのカードの場所が分かっている。カードのない行と列をなくした後にそれぞれのカードが置かれた位置をすべて求める。
  行、列ごとに別々に処理する。setで既に現れたかチェックしてユニークな値をvectorに入れる。それをsortしてmapに番号と順位の関係を作って、各数字を順位に変換する。
  他に、座圧、二分探索を使っても解ける
}

スタック{
  ABC338 E - Chords
  円周上に2N個の点が等間隔に並んでおり、N本の弦が端点を共有することなく張られている。弦同士の交点が存在するか判定する。
  円を切り開いて点を順番に見る。ある点の弦が初めて登場する場合、もう片方の点をstackに積む。登場済みの場合、その点がstackの一番上なら取り除く。一番上でないなら交点が存在する。

  鉄則 B51 - Bracket
  対応の取れている括弧列がある。何文字目と何文字目が対応しているかを全て出力する。
  '('の場合スタックに何文字目か格納、')'の場合取り出して出力。
}

パリティ{
  ABC125 D - Flipping Signs
  数列の隣り合う2つの要素に-1を乗算する操作を任意の回数行い、数列の和を最大化する
  マイナスの要素が偶数か、要素に0を含むなら全てプラスにできるのでマイナスの要素の数のパリティを調べる

  ABC134 D - Preparing Boxes
  iの倍数の箱のボールの和を2で割った余りがaiになるように、箱にボールを0個または1個入れる
  後ろから確定しているのでエラトステネスの篩のような処理を後ろから行う
}

しゃくとり法{
  ABC124 D - Handstand
  N人の人が一列に並んでいる。各人は直立または逆立ちしている。区間を指定して状態を反転させる操作を最大K回行う事で逆立ちした人を連続で最大何人並ばせることができるか求める。
  ランレングス圧縮して、しゃくとり法をする。

  ABC130 D - Enough Array
  正整数列の連続する部分列のうちK以上となるものの数を数える
  しゃくとり法で条件を満たすものを求める

  ABC247 E - Max Min
  長さNの整数列Aと、整数X,Yがある。1<=L<=R<=Nかつ要素LからRまでの最大値はXで最小値はYであるL,Rの組の個数を求める。
  Y未満、X超過で区切った区間で考える。詳しくはコードを見る。または包除原理で解ける。

  ABC250 F - One Fourth
  凸N角形のピザがある。このピザを頂点対でカットし1/4の面積になるべく近くする。面積の1/4との差分の8倍の最小値を求める。
  点1を基準に隣の三角形を加えていく。合計が1/4以上になったら点1,点2と最後の点のなす三角形を減じて点2を基準にする。これを繰り返して答えを求める。三角形の面積は外積で求められる。

  ARC022 B - 細長いお菓子
  長さNの細長いお菓子がある。長さ1毎にブロックに分かれており、それぞれある味がついている。同じ味のブロックが含まれないような最大の連続する部分列の長さを求める。
  味の種類毎に選択区間内の登場数を記録してしゃくとり法をする。

  典型90 034 - There are few types of elements（★4）
  数列と整数Kが与えられる。要素の種類がK以下の連続する部分列の最大の長さを求める
  数字の登場回数をmapで管理し、しゃくとり法で条件を満たすように範囲を動かす

  典型90 076 - Cake Cut（★3）
  N個のピースに分かれたホールケーキの連続する部分のうち、全体の大きさのちょうど10分の1になるものは存在するか判定する。
  しゃくとり法で解いたが、解説は二分探索だった。二分探索の方がややこしく感じる。
}

順列{
  ABC145 C - Average Length
  next_permutationで全パターンの距離を求めて平均化する

  ABC183 C - Travel
  最大8個の都市を1度ずつ訪問する移動時間がちょうどKになる経路を数え上げる
  next_permutationで全パターン調べる

  ABC198 D - Send More Money
  覆面算を解く
  文字毎の登場位置から係数をmapに入れて、next_permutationで全パターン試す。見つかったらmapに数字を割り当て直して出力に使う。

  ABC332 D - Swapping Puzzle
  H行W列の2つのグリッドA,Bが与えられる。Aのi行目とi+1行目を入れ替える、i列目とi+1列目を入れ替えるのどちらかの操作を繰り返しAをBに一致させる最小手数を求める。一致不可なら-1を出力する。
  縦横は独立に考えられる。入れ替え方を順列にして縦横組み合わせて全列挙し、一致した場合操作回数を求める。操作回数は順列の転倒数と一致する。

  ARC013
  N*M*Lのサイズのダンボールに、P*Q*Rのサイズの荷物を方向を揃えて詰め込む。はじめに方向を選べるときに最大いくつ詰められるか求める。
  詰める方向をnext_permutationで全探索する。

  典型90 032 - AtCoder Ekiden（★3）
  各選手の各区間と、タスキを渡せない噂が与えられる。駅伝の出走順を決め、最速タイムを求める。
  next_permutationで全パターン試し、噂がないケースでタイムを更新する。
}

組み合わせ{
  ABC034 C - 経路
  H×Wのグリッドがある。左上をスタートして下または右に移動して右下を目指す。経路の個数を10^9+7で割った余りを求める。
  c(H+W-2,H-1)が答え。

  ABC057 D - Maximum Average Sets
  N個の品物がある。品物からA個以上、B個以下を選ぶときの価値の平均の最大値を求める。また平均が最大となるような選び方が何通りあるか求める。
  価値の平均の最大値は最低個数のA個貪欲に取ればよい。パターン数は最低価値の品物の入れ替えを考えれば良い。
  平均最大化で選択したすべての品物が同じ価値でない場合は、最低価値の品物の全体個数から採用する個数を選ぶ組み合わせを求める。
  選択したすべての品物が同じ価値の場合は、選択可能個数を変更できるので、全ての場合の組み合わせを足し合わせる。
  組み合わせはパスカルの三角形で求めておく。

  ABC151 E - Max-Min Sums
  整数の集合Xに対し、f(X)=maxX-minXと定義する。N個の整数からK個選び集合Sとする。Sの選び方はNCK通りあるが、f(S)の合計をmod10^9+7で求める。
  Aをソートする。ある数が最大、最小となるパターン数を求め、答えに加算、減算する。

  ABC156 E - Roaming
  1からnまでの番号がついている部屋がある。最初、各部屋には1人ずつおり、ここれまでにk回の移動があった。各部屋にいる人の数の組み合わせとしてあり得るものは何通りか(10^9+7)で割った余りを求める。
  空になる部屋の数を固定し、(空になる部屋のパターン)*(部屋の人数のパターン)を答えに足し合わせていく。但し、k=1の時のみ空になる部屋を0にすることはできないので例外処理する。

  ABC168 E - ∙ (Bullet)
  N匹のイワシが釣れた。i匹目のイワシの美味しさはAi、香り高さはBiである。この中から1匹以上のイワシを選んでクーラーボックスに入れる。仲が悪いイワシを2匹同時に選べない。Ai*Aj+Bi*Bj=0で仲が悪い。イワシの選び方を10^9+7で割った余りを求める。
  各イワシのパラメータを正規化してmapで管理する。条件を満たすパターンを計算していく。(解説は理解出来なかった。全体から引くなら理解できる)

  ARC039 B - 高橋幼稚園
  N人の児童にK個のキャンディを配る。幸福度を各児童が受け取ったキャンディの個数の積とする。幸福度を最大にする配り方が何通りあるか、10^9+7で割った余りを求める。
  幸福度が正の場合はN!/(多くもらう人数!*少なくもらう人数!)、0の場合は(N+K-1)C(N-1)が答え。

  ARC058 D - いろはちゃんとマス目
  H×Wのマス目があり、一番左上のマスにいる。左下に移動不可の領域がある。右か下に1マスずつ移動し右下に至るパターン数を10^9+7で割った余りを求める。
  移動不可の領域の行数に移動する場合毎に考えて足し合わせる。
  
  ARC134 C - The Majority
  1からKの箱と1からNの整数が書かれたボールがいくつかある。ボールiはai個あり、同じ整数のボールは区別できない。すべてのボールを箱に入れる。どの箱についても1のボールが過半数を占めるようにする。しまいかたのパターン数を998244353で割ったあまりを求める。
  1以外のボールの個数+箱の個数の1のボールは場所が決まっており、これを減じる。1のボールが足りなければパターン数は0。足りる場合はそれぞれのボールの配置パターン数を掛け合わせる。nCkのnが大きいのでstruct combinationが使えず、また最後に一度で割らないとTLEになるので、新たに関数を持ってきた。

  ARC143 B - Counting Grids
  N×Nマスに1からN^2の整数を1つずつ書き込む方法であり、どのマスも以下の2条件の少なくとも一方を満たすようなものの個数を998244353で割ったあまりを求める。
  1.そのマスの数より大きい数が書かれているマスが同じ列に存在する。
  2.そのマスの数より小さい数が書かれているマスが同じ行に存在する。
  全体から条件を満たさないパターン数を減じる。満たさないマスが存在する場合、実は該当するマスは1つのみ。構成する行列の集合のパターン数はC(N^2,2N-1),それらの並べ方が(N-1)!*(N-1)!,それ以外の並べ方が(N-1)^2!,該当マスの選び方がN^2,これらを掛け合わせたものを全パターンであるN^2!から減じる。

  AGC031 A - Colorful Subsequence
  文字列Sがある。Sの部分列であって、すべて異なる文字から成るものを10^9+7で割った余りを求める。文字列として同一でも異なる位置から取り出された部分列は区別する。
  ある文字はどこかの位置で登場するかしないかなので、登場数+1をすべての文字種について掛け合わせて、最後に1を減じると答え。

  AGC051 A - Dodecagon
  辺の長さが1の正方形と正三角形のタイルを組み合わせて辺の長さがdの正12角形を作る方法が何通りあるか求める。
  C(2*d,d)/2が答え。
}

重複組み合わせ{
  ABC021 D - 多重ループ
  1<=a1<=a2..ak<=nであるような整数の組(a1,a2,..ak)の個数を求める。
  重複組み合わせnHk=(n-1+k)C(n-1)が答え。因みに問題文に=がなければnCkが答え。

  ABC110 D - Factorization
  長さNの数列で、要素の総積がMとなる数列が何通りあるか10^9*+7で割った余りを求める。
  Mを素因数分解する。素因数の種類毎に、N箇所のどこに数字を割り当てるかパターン数を求めて掛け合わせる。各割当てパターン数はNHcnt=(N+cnt-1)C(cnt)である。

  ABC167 E - Colorful Blocks
  N個のブロックが横一列に並んでいる。このブロック列に色を塗る。次の条件を満たすブロック列の塗り方が何通りか998244353で割った余りを出力する。色の種類はMで使わない色があってもよい。隣り合うブロックの組で同色の組はK組以下である。
  K組をkに固定すると、同色グループ数は(N-1)C(K)、色分けパターン数はM*(M-1)^N-1-kでありこれらの積が答え。kが大きい方から計算し、k<=Kのときにansに加えていくと最終的な答えが求まる。
  220321解き直し:同色のi組を固定し、それ以外のN-i個のパターンはM*pow((M-1),(N-i-1))、N-i個からi個を選ぶ重複組み合わせ(N-i)H(i)を掛け合わせると、このiでのパターン数になるので、iを0からKまで回して足し合わせる。

  ARC023 C - タコヤ木
  狭義単調増加の数列が与えられる。数列のうちいくつかの要素が不明になっている。あり得るパターン数を1000000007で割った余りを求める。
  不明の区間ごとに重複組み合わせを求めて掛け合わせる。数列に含まれる数字の上限が大きくNが小さいので毎回掛け合わせて求める。
}

包除原理{
  ABC089 D - Practical Skill Test
  H×Wのマスがあり、1からH×Wまでの整数が重複なく書かれている。マンハッタン距離のコストで駒を別のマスに移動できる。Q回の実技試験を受ける。初めに駒がLiの書いてあるマスに置かれている。駒の置かれているマスの整数をxとする。xがRになるまでx*Dのマスに移動する事を繰り返す。それぞれの実技試験に対し、コストの総和を求める。
  前計算で最左からその数字に至るまでのコストを求める。各クエリに対してdp[r]-dp[l]が答え。

  ABC152 F - Tree and Constraints
  N頂点の木がある。この木の各辺を白か黒に塗る。次のM個の制約を全て満たすものの個数を求める。制約:頂点uiとviを結ぶパスに含まれる辺のうち黒く塗られているものが1つ以上存在する。
  各条件を満たさないパターン数は条件に含まれる辺が全て白なので簡単に求められる。全パターンから条件を満たさないパターンを減じる。条件の組み合わせをbit全探索でまわし、包除原理をする。
  
  ABC154 F - Many Many Paths
  2次元平面がある。一回の操作で右または下に1進める。f(r,c)を(0,0)から(r,c)への経路の個数とする。r1<=i<=r2かつc1<=i<=c2を満たす全ての整数の組(i,j)の総和を10^9+7で割った余りを求める。
  (0,0)から(r,c)までのすべての組合わせの総和(2次元状)は(r+c+1)C(r+1)-1で求められる。二次元累積和のように4箇所で求めて足し引きすると答えを求められる。

  ABC172 E - NEQ
  1以上M以下の整数からなる長さNの数列A,Bの組であり、以下の条件をすべて満たすものの個数を(10^9+7)で割った余りを求める。
  条件1:1<=i<=Nなる任意のiについてAi!=Bi
  条件2:1<=i<j<=Nなる任意の(i,j)についてAi!=AjかつBi!=Bj
  全パターンからAi=Biを少なくとも1つ含むパターン数を減じる、少なくとも2つ含むパターン数を加える...を繰り返して求める。

  ABC178 C - Ubiquity
  要素に0と9を含む長さNの数列のパターン数を求める
  10^N-9^N-9^N+8^Nを出力する
  最初DPで解いた

  ABC178 C - Ubiquity
  長さNの数列であって次の条件を満たすものの数を求める。0<=Ai<=9,Ai=0なるiが存在する,Ai=9なるiが存在する。
  10^N-9^N-9^N+8^Nが答え。

  ABC200 E - Patisserie ABC 2
  「綺麗さ」がi,「おいしさ」がj,「人気度」がkであるケーキを全ての組(i,j,k)(1<=i,j,k<=N)に対して1つずつ作った。N^3個のケーキを次の順で並べる。i+j+kが小さいものをより左に並べる、「綺麗さ」が小さいものをより左に並べる,「おいしさ」が小さいものをより左に並べる。左からK番目にあるケーキの各パラメータを求める。
  包除原理で合計がsになるパターン数を求める。つまり3つOKかもしれない-2つOKかもしれない1つNG+1つOKかもしれない2つNG-3つNGで計算する。それによりK番目のパラメータの合計値を求める。その後右2つで合計がsになるパターン数を求める関数を使いaを決める。その後b,cを全探索。

  ABC246 F - typewriter
  N段からなるタイプライターがある。その中の1段だけ選択し、L文字入力する。入力可能なL文字の文字列は何通りか、998244353で割った余りを求める。
  包除原理で重複を除いて求める。

  ABC269 F - Numbered Checker
  N行M列のグリッドがあり、i行j列には(i-1)*M+jが書かれている。このグリッドのi+jが奇数なら0に置き換える。操作後のグリッドについて矩形内の合計を求めるQ個のクエリに答える。
  矩形領域内は初項と末項の平均に項数を掛けると求められる。奇数行と偶数行を分け、左上を左上隅に固定し包除原理を使うと処理を共通化出来る。

  ABC297 F - Minimum Bounding Box 2
  H×Wのグリッドがあり、ここからランダムにKマス選ぶ。選んだマスをすべて含む最小の長方形に含まれるマスの個数をスコアとする。スコアの期待値をmod999244353で求める。
  各マスについて、そのマスがスコアに寄与するパターン数を求め、全パターン数で割る。スコアに寄与しないパターン数は選択されるマスがすべて対象マスより下等に偏っている場合なので包除原理で求められる。全パターンからこの値を減じるとスコアに寄与するパターン数となる。

  ABC343 E - 7x7x7
  座標空間上に一辺7の立方体を3つ配置する。ちょうど1,2,3個の立方体に含まれる領域の体積がそれぞれV1,V2,V3となるように配置出来るか判定する。出来る場合は配置する座標を求める。
  配置を全通り試す。ちょうど1,2,3個の立方体に含まれる領域の体積は包除原理で求める。

  ARC112 B - -- - B
  整数B、C円が与えられる。Bを1円で-1倍、2円で-1できる。C円以内で作れる整数は何通りか求める
  +B,-B付近のパターンを作れ、領域が重なる事があるので包除原理で求める。

  CODE_FESTIVAL2017qualC B - Similar Arrays
  各要素の差が1以内の数列を「似ている」とする。数列Aが与えられるので、数列Aと「似ている」数列のうち、すべての河野積が偶数となるものの個数を求める。
  全パターンから全ての項が奇数のパターンを減じて答えを求める。
}

約数包除{
  ABC162 E - Sum of gcd of Tuples (Hard)
  1以上K以下の整数からなる長さNの数列を考える。それら全パターンのすべての要素の最大公約数の和を10^9+7で割った余りを求める。
  GCDがある数になるパターン数を求める事で答えを求める。求めるときは大きな数から行い、約数包除をする。

  ABC206 E - Divide Both
  L,Rが与えられるので、次の条件を全て満たす整数組の数を求める。L<=x,y<=R、xとyのgcdをgとするとg!=1かつx/g!=1かつy/g!=1である。
  gcdを固定して大きい方からまわし、まずgcdの倍数を含むパターン数を求める。そこから既に求めた倍数のパターン数を減じることで倍数を含まないパターン数を求める。最後に要素にgcdちょうどのものを含むものを減じる。
  // 最後の処理が分かっていない

  ABC304 F - Shift Table
  高橋君と青木君はN日間アルバイトをする。高橋君のシフト表が与えられる。青木君は次のようにシフト表を作る。まず、NでないNの正の約数Mをとる。次に1日目からM日目までの勤怠を決める。最後にその勤怠を繰り返す。N日すべてについていずれか1人は出勤するような青木君のシフト表の個数を998244535で割った余りを求める。
  制約より約数の個数は128個以下と多くない。全ての区間のパターンを試す。区間長Mの約数となる区間長のパターンは区間Mにすべて含まれるので除外するような包除をして答えを足し合わせていく。
}

N進数{
  ABC105 C - Base -2 Number
  整数Nの-2進数表現を求める。
  Nを2で割った余りが0でなければNを-1して答えの先頭に1を加える。余りが0なら先頭に0を加える。その後Nを2で割る。これをNが0でない間繰り返す。

  ABC171 C - One Quadrillion and One Dalmatians
  1,...,26番目にa,...,z、27番目にaaと名前を付けていく。N番目の名前を求める。
  26進数のようにN%26,N/26をすれば良さようだが、zの次がbaでなくaaなので各桁を求める前にN-1する。
}

二分探索{
  ABC006 D - トランプ挿入ソート
  異なる数字が書かれたN枚のカードの山がある。山札から任意のカードを1枚抜き取り任意の場所に挿入する操作を最低何回行うとカードを昇順にソートできるか求める。
  単調増加枚数を達成するときの最後のカードの最小値をvectorで管理する。初期状態の山札の上からそのvectorを二分探索して更新していく。N-単調増加枚数の最大値が答え。

  ABC020 C - 壁抜け
  マス目をスタートからゴールまでT秒以内に移動する。白マスは1秒、黒マスはx秒かかる。xの最大値を求める。
  xを二分探索で決め打ちする。判定はBFSのように進んで行う。
  
  ABC026 D - 高橋君ボール1号
  高橋君ボール1号は投げてからt秒後のボールの位置をf(t)=A*t+B*sin(C*t*PI)で表せる。f(t)=100となるtを求める。
  正解になるtは複数あるが、二分探索でそのうちひとつを求められる。

  ABC063 D - Widespread
  N体の魔物がいる。魔物を1体指定して爆発で攻撃すると指定した魔物の体力をA,それ以外をB減らす。A>Bである。最小で何回の爆発ですべての魔物を倒せるか求める。
  爆発回数を二分探索で求める。

  ABC 119 D - Lazy Faith
  道に沿ってA社の神社とB軒の寺が建っている。Q個の問に答える。西端からxiメートルの地点から出発して道路上を自由に移動する時、神社一社と寺一軒を訪れる最短距離は何メートルか。
  現在地から左右方向にそれぞれ最寄りの神社と寺までの距離をそれぞれ二分探索で求め、神社と寺の左右と訪問順の組み合わせ6通りを求めて最短のものを答える。

  ABC134 E - Sequence Decomposing
  N要素の数列Aが与えられる。N個それぞれの整数に対して、色を1つ選んで塗る。このとき、AiとAjが同色ならAi<Ajとなるようにする。用いる色の最小値を求める。
  登場済みの要素をdequeで管理する。dequeの中身を二分探索で自分以上の要素番号を探し、見つかった要素番号-1の要素を自分で上書きする。見つかった要素番号が0ならpush_frontで先頭に追加する。

  ABC143 D - Triangles
  N本の棒がある。三角形の作り方が何通りあるか求める。
  2本を全探索する。3本目の候補本数を二分探索で求める。別解ではまやんさんの累積和を使う方法で解いた。

  ABC144 E - Gluttony
  早食い大会に出る。N人のチームメンバーがおり、メンバーiの消化コストはAiである。N個の食べ物があり、食べ物iの食べにくさはFiである。食べ物の完食にはA*F秒かかる。N人のメンバーにそれぞれ別々の食べ物を割り振り、完食にかかる時間の最大値が成績となる。メンバーN人で合計K回、消化コストを1減らす修行を行えるとき、成績は最小でいくつにできるか求める。
  達成できる成績を決め打ちして二分探索する。各人必要なだけの修行を行い、修行回数がKを越えなければOK。

  ABC146 C - Buy an Integer
  整数屋さんで整数を1つ買う。整数屋さんには1以上10^9以下の整数が売られている。整数Nを買うにはA*N+B+d(N)円が必要である。d(N)は十進表記でのNの桁数を表す。所持金がX円のとき、購入可能な最大の整数を求める。購入不可の場合は0を出力する。
  決め打ち二分探索で求める。最大数を超えた場合は10^9にする。

  ABC149 E - Handshake
  N人のゲストがおり、各人のパワーはAiである。2人を選ぶことをM回行い、選択した2人(同一人物の選択可)のパワーの合計値をスコアに加える。M回の選択で同じ組み合わせを選ばないとき、スコアの最大値を求める。
  採用数がM以上になる中で最も高い最低点と合計点を求める。これは二分探索で可能。最後に加えすぎた点を減じる。

  ABC174 E - Logs
  丸太がN本あり、長さはA1,A2,...,ANである。丸太をK回切ったときの最も長い丸太の長さの最小値を求める。
  最大値の最小化。丸太の長さを決め打ちして二分探索する。

  ABC192 D - Base n
  0～9からなる文字列Xと整数Mが与えられる。Xの最も大きい数字をdとする。d+1以上の整数nを選んでXをn進法表記の数とみなして得られる値のうち、M以下であるようなものは何種類あるか求める。
  二分探索で何進法まで条件を満たすか求める。オーバーフローを防ぐため、Mをn進法で表して比較する。
  
  ABC203 D - Pond
  N*Nマスから高さの中央値が最も低いK*Kマスを選ぶ。最も低い中央値を求める。
  中央値を決め打ちし、達成できるか二分探索で求める。K*Kマスの中央値は二次元累積和で高速に求める。

  ABC215 F - Dist Max 2
  2次元平面上のN個の相異なる点が与えられる。2つの点の距離をmin(|xi-xj|,|yi-yj|)と定義する。異なる2つの点の距離の最大値を求める。
  最小値の最大化は二分探索。決め打ち二分探索をする。ある距離dが条件を満たすかの判定は、(x,y)のペアを昇順にソートしておき、点を1つずつ見て自分よりd以上左にある点のy座標の最大最小を求めてどちらかが自分のy座標よりd以上離れているか見る事で行う。y座標の最大最小の更新は平面走査をしてO(N^2)にならないようにする。

  ABC236 E - Average and Median
  N枚のカードがあり、それぞれ整数が書かれている。ここから好きな枚数を選ぶ。ただし、2枚連続して取らない事があってはならない。このとき、平均値の最大値、中央値の最大値を求める。
  決め打ち二分探索。平均値は、決め打ちした平均値をすべての要素から引いた配列を新たに作って判定する。中央値は、その数以上の数なら1にして取れる1をすべて取り、取らなければならない0の個数を数えて、zero<=one-1なら達成できると判定する。平均値は回数を決め打ちで50回にしている。

  ABC292 F - Regular Triangle Inside a Rectangle
  縦A横Bの長方形の内部に描ける正三角形の一辺の長さの最大値を求める。
  A<Bとする。3頂点のうち1つは角にあるとしてよい。Bに接するケースではx=A*2/√3がB以下ならこれが最大。その他は角に接する頂点の傾ける角度を二分探索する。三角形の2つの辺の長さはA*cos(rad30-mid)とB*cos(mid)であり、A*cos(rad30-mid)-B*cos(mid)<0で分岐し、この式が0になるmidを求めて、それを角度として辺の長さを計算する。

  ARC037 C - 億マス計算
  N^2マス計算の小さい方からK番目の値を求める。
  目的の数を求める部分と、条件を満たす個数を求める2箇所で二分探索を使う。

  ARC049 B - 高橋ノルム君
  2次元平面上にN人の高橋ノルム君がいる。各人に座標xi,yiとciが割り当てられている。(X,Y)に移動するにはci*max(|xi-X|,|yi-Y|)の時間がかかる。一点に集まるために必要な最小の時間を求める。
  X,Yを別々に考える。移動時間を決め打ちして、二分探索。判定は各人の移動範囲の左端の右端、右端の左端が逆転していないか見る。

  ARC050 B - 花束
  赤い花がR本、青い花がB本ある。x本の赤い花と1本の青い花からなる花束と、1本の赤い花とy本の青い花からなる花束を作る事ができる。作成可能な花束の最大個数を求める。
  どちらの花束を作るにも赤い花青い花をそれぞれ1本ずつは必ず使う事に気を付けて二分探索。

  ARC109 B - log
  丸田やさんに長さ1からn+1までのn+1種類の丸太がそれぞれ1円で売られている。丸太を何度でも切れるとき、長さ1からnまでのn種類の丸太を1本ずつ手に入れる最小コストを求める。
  長さn+1の丸太で短い方から作るのが最適。二分探索でどこまで作れるか求める。

  AGC041 B - Voting Judges
  N問の問題が提案された。はじめ、問題iのスコアはAi。これからM人のジャッジがちょうどV問に投票しスコアを1ずつ上げる。全員の投票後に問題がスコアの降順に並べられ、最初のP問が採用される。採用される可能性のある問題の数を求める。
  問題を降順にソートし、二分探索する。まず、対象が既に上位P以内なら、採用される。M票投票してもP位の票数を下回るなら採用されない。上位P-1はM票投票してよい。対象以下の問題にもM票投票してよい。それ以外は対象の問題のスコアを超えない範囲で投票してよい。これらの票数の合計がM*Vを超えなければ採用される可能性がある。

  典型90 001 - Yokan Party（★4）
  長さLのようかんにN個の切れ目が付いている。それぞれの切れ目の位置はAi。K個の切れ目を選ぶ時、ようかんの長さの最小値を最大化し、その長さを求める。
  答えを決め打ちし、達成できるか二分探索で求める。

  典型90 007 - CP Classes（★3）
  生徒の不満度が最低になるようにクラスに割り当てる
  クラスをソートして割り当てるクラスを二分探索

  鉄則 C07 - ALGO-MARKET
  N個の品物がある。Q個の質問に答える。各質問はX円持っているとき最大何個の品物を買えるか。
  ソートして、累積和をとり、二分探索。

  DISCO presents ディスカバリーチャンネル プログラミングコンテスト2016 本戦 B - DDPC特別ビュッフェⅡ
  N種類の料理がありi種類目の料理はTi秒後になくなり,美味しさはAiである。料理をトレーに載せるのに1秒かかる。美味しさの総和がX以上になるために必要な最小の時刻を求める。
  終了時間を決め打って二分探索する。終了時間を決めると時間の遅い状態から考えて取れる料理の中から貪欲に最大の美味しさを採用するとよい。

  エクサウィザーズ C - Snuke the Wizard
  Nマスが一列に並んでいる。各マスには文字が書かれており、1体ずつゴーレムがいる。Q回呪文を唱え、指定した文字のゴーレムを指定した方向に1マス移動させる。マスの外に出たゴーレムは消滅する。Q回の呪文の後に消滅していないゴーレムの総数を求める。
  ゴーレムの順番は入れ替わらない。二分探索で左に落ちない初期位置、右に落ちない初期位置を求めると最終状態で残る区間が分かる。

  ZONeエナジー プログラミングコンテスト “HELLO SPACE” C - MAD TEAM
  N人のメンバー候補がおり、それぞれ5種類のパラメータを持つ。N人から3人選び、チームの各パラメータをチームメンバーの各パラメータの最大値と定義する。チームの総合力をチームの各パラメータの最小値と定義する。総合力の最大値を求める。
  二分探索で求める。mid以上を1、未満を0として、or演算で判定すると良い。
}

三分探索{
  ARC 054 B - ムーアの法則
  タカハシマン関数の計算には現代のコンピュータではP年かかる。コンピュータの速度は1.5年毎に2倍になる。計算が終わるまでの最短の時間を求める。
  三分探索する。
}

クエリソート{
  典型90 007 - CP Classes（★3）
  生徒をソートして、復元した
  想定解法は二分探索だった
}

角度{
  ABC144 D - Water Bottle
  底辺が1辺acmの正方形で高さがbcmの直方体の水筒がある。体積xcm^3の水を入れ、底面の正方形の1辺を軸として徐々に傾けたとき、水を溢れさせずに傾けられる最大の角度を求める。
  水筒の対角を超える体積かどうかで場合分けし、溢れる直前の横からみた面積を計算してatan2を使って角度を求める。

  ABC168 C - : (Colon) 
  時計の針の長さと時刻が与えられる、時針と分針の先端の距離を求める。
  sin,cosで針先の位置を求め、三平方の定理で距離を求める。
  
  典型90 018 - Statue of Chokudai（★3）
  観覧車から見た像の角度をatan2で求める
}

場合の数{
  ABC132 D - Blue and Red Balls
  K個の青いボールとN-K個の赤いボールがある赤いボールを仕切りにして
  青いボールをi個のグループに分けるときの場合の数を1<=i<=Kの全てのi
  について求め10^9+7で割ったものを答える
  場合の数を頑張って求める
}

繰り返し二乗法{
  典型90 075 - Magic For Balls（★3）
}

累積和{
  ABC037 C - 総和
  長さNの数列と整数Kが与えられる。この数列には長さKの連続する部分列がN-K+1個ある。これらの部分列の合計の総和を求める。
  累積和を求めておき、あり得る区間の和を全て足し合わせる。

  ABC067 C - Splitting Pile
  N枚のカードの山を順番を変えずに2つに分ける。それぞれの合計の差の最小値を求める。
  累積和を前計算し、分ける位置を全探索する。

  ABC098 C - Attention
  N人が東西方向に並んでおり、各人は東または西を向いている。リーダーを1人決め、他の人をリーダーの方を向くように向きを変える。リーダーを適切に選ぶとき、向きを変える人数の最小値を求める。
  累積和である人までに東を向いている人、西を向いている人の人数をカウントしておく、リーダー候補を全探索し、向きを変える人数をO(1)で求めて、最小値を求める。

  ABC146 E - Rem of Sum is Num
  長さNの正整数列Aと正の整数Kが与えられる。Aの空でない連続する部分列であって、要素の和をKで割った余りが要素の数と等しくなるものの数を求める。
  Aの各要素を-1し、余り=要素の数でなく、余り=0の問題に変換する。累積和をmodKで求める。累積和を順にまわして、これまでに登場した、余りが同一になる区間の数を答えに加算する。このとき、区間長がK以上のものは答えに不適なので、区間長がK以上になったらqueueで登場順に管理して対象の値をデクリメントする。登場回数はmapで管理する。

  ABC181 E - Transformable Teacher
  N人(奇数)の児童がおり、先生を含めてペアを作る。先生はM個の変身形態がある。各ペアの身長差の合計の最小値を求める。
  N人をソートして、左から、右からの累積和を前計算する。先生の変身形態を全探索する。二分探索で、先生とペアにする児童を求めて身長差の合計を求めていく。

  ABC203 D - Pond
  N*Nマスから高さの中央値が最も低いK*Kマスを選ぶ。最も低い中央値を求める。
  中央値を決め打ちし、達成できるか二分探索で求める。K*Kマスの中央値は二次元累積和で高速に求める。

  ABC288 D - Range Add Query
  整数列Aと正整数Kが与えられる。Q個のクエリについてAの連続部分列Al,..,Arが良い数列か判定する。良い数列とは区間Kに同一の整数を加える操作を好きなだけ行い、全ての要素を0に出来るものである。
  modK毎に要素を並べて、区間[l,r]内の合計値が全てのmodKで同一であれば良い数列である。

  ARC052 B - 円錐
  3次元空間にNこの円錐がある。底辺がyz平面と平行である。Q個のクエリでA,Bが与えられるので、A<=x<=Bの空間の円錐の体積の合計を求める。
  区間1の体積の和を求めた後、累積和を取り、クエリにO(1)で答えていく。

  ARC119 C - ARC Wrecker 2
  N棟の横一列に並んでおり、それぞれの高さはA1,..,ANである。整数l,rを選び、すべての高さを0にしようと計画している。隣り合うビルの高さを両方1増やすか、1減らすかの操作のみでこれを達成できるl,rの組み合わせが何通りあるか求める。
  隣り合うもの同士に同様の数を加えるので、奇数番目と偶数番目の合計が等しければ条件を満たす。偶奇で符号を反転させた数列で累積和を取り、同じ数同士の組み合わせの数が答えなので、mapを用いて順番に数え上げる。尚、累積和の先頭に0の要素を加えておく。

  ARC150 A - Continuous 1
  0,1,?のみからなる長さNの文字列が与えられる。?を0,1のいずれかに置き換えることで次の条件をすべて満たすようにする。Sは1をちょうどK個含む、K個の1は連続している。これを満たす?の置き換え方がちょうど1通りであるか判定する。
  0の個数、1の個数の累積和を前計算しておき先頭から判定する。

  AGC023 A - Zero-Sum Ranges
  整数列Aの空でない連続する部分列であって、総和が0になる区間の個数を求める。
  累積和を取り、各数の登場回数を求める。同一の数から2つ選ぶ組み合わせの数の総和が答え。
}

二次元累積和{
  ABC331 D - Tile Pattern
  縦横10^9マスのグリッドがある。それぞれのマスはN*Nのパターンで白黒に塗られている。左上(A,B)、右下(C,D)の領域内の黒マスの個数を求める。
  左上を(0,0)に固定して4矩形の包除原理で求める。各矩形はNの倍数と余りで4領域に分けて求める。

  ARC025 B - チョコレート
  H,Wマスのチョコレートがある。各マスはブラックチョコかホワイトチョコの市松模様である。それぞれのチョコレートには濃度が設定されている。この中からブラックとホワイトそれぞれの濃度の合計が等しくなるように矩形領域を切り出す。矩形領域の最大マス数を求める。
  黒は正、白は負にして二次元累積和が0になる領域が採用可能。

  鉄則 B09 - Papers
  二次元平面状にN枚の紙がある。1枚以上の紙が置かれている部分の面積を求める。
  二次元累積和を構築した後、要素が1以上であるものを数え上げる。
}

エラトステネスの篩{
  ABC149 C - Next Prime
  X以上の素数のうち、最小のものを求める。
  エラトステネスの篩で素数かどうかを示す配列を作り、Xから加えていって見つける。

  ABC177 E - Coprime
  N個の整数Aがある。全ての2つの組み合わせでGCDが1の場合pairwise coprime、全てAのGCDが1の場合setwisse coprime、そのどちらでもない場合not coprimeと出力する。
  各数の登場回数を記録し、2から順番に因数を固定しエラトステネスの篩のようにその因数で割り切れるAの個数を調べる。
}

浮動小数点{
  ABC169 C - Multiplication 3
  A*Bの小数点以下を切り捨て、結果を整数で出力する。Aは整数Bは小数第2位まで。
  Bを100倍してA*Bした後100で割る。Bを受け取る際はscanfで整数部、小数部を分けるか、doubleで受け取り100倍して0.5等を加えて誤差を消す。

  AGC047 A - Integer Product
  N個の実数が与えられる。積が整数である2つの組み合わせの個数を求める。
  小数点以下をなくすため、10^9をかける。受け取りをaとし、int a_int=(int)round(a*1000000000)とする。各数字が2で何回、5で何回割れるか調べて度数を求める。2つの数をかけて10^18の倍数になっている事が達成条件なので、2^18且つ5^18を満たす組み合わせを求める。この部分の計算量は19^4。
}

鳩ノ巣原理{
  ABC167 D - Teleporter
  N個の町があり、各町には行先が固定されたテレポーターがある。町1から出発してテレポーターをちょうどK回使うとどの町に到着するか求める。
  ループの開始、終了がどこか求める。Kがループ前ならそのままシミュレーションする。ループ後なら周期性を利用して解く。

  ABC174 C - Repsept
  7,77,...で最初にKの倍数になるものをmodと鳩ノ巣原理の組み合わせで求める

  ABC179 E - Sequence Sum
  xをmで割った余りをf(x,m)とする。A1=X,An+1=f(An^2,M)とし、i=0からNまでのAiの合計を求める。
  Aiは高々10^5種類でループするので鳩ノ巣原理でループ部分を掛けて加える。

  ABC260 F - Find 4-cycle
  S+T頂点M辺の単純無向グラフGがある。S,T内は独立でありそれぞれの頂点を結ぶ辺は存在しない。長さ4のサイクルのうち1つを選び、それに含まれる頂点を出力する。存在しない場合-1を出力する。
  頂点数が多い方のSをまわし、Tのどの2点に同時に接続されているかの組み合わせをT^2サイズの2次元配列に記録する。これだけだとO(S*T^2)だが、4-cycleを1つだけ見つければ良く、T^2も見れば鳩ノ巣原理より必ず見つかるのでO(T^2)で解ける。

  典型90 058 - Original Calculator（★4）
  NにNの各桁の数の和を加えて10^5の余りを新たなNにする操作をK回実施した後のNを求める。
  周期性を利用してループ区間を求める。
}

周期性(上の鳩ノ巣原理にも同様のものがある){
  ABC030 D - へんてこ辞書
  英単語帳にはNこの単語の意味が載っており、どの単語と同じかのみ書いてある。ある単語をkステップ調べた後、どの単語を調べようとしているか求める。
  kがとても大きい。ループに入るまでをTループ長をCとする。kが10^5以下ならシミュレーションする。そうでなければ、桁の上からkmodCを求めていき、最後に引きすぎたCを加えてからシミュレーションする。

  ABC241 E - Putting Candies
  長さNの数列が与えられる。最初に空の皿があり、次の操作をK回繰り返す。皿の中のアメの個数をXとする。さらにA(XmodN)個のアメを追加する。K回の操作後のアメの個数を求める。
  
  ARC118 A - Tax Included Price
  消費税率tパーセントで現れない価格の小さい方からN番目を求める。
  税抜き価格1から100までで必ず周期性を持つ。N番目が何周期目の何番目か求めて計算する。
}

ランレングス圧縮{
  ABC140 D - Face Produces Unhappiness
  N人の人が並んでいる、向いている方向がL,Rで表される。目の前の人が自分と同じ方向を向いていると幸福である。l,rを選び、その人たちを180度回転させる操作を最大K回繰り返し、幸福である人を最大何人にできるか求める。
  ランレングス圧縮して、LとRの交互にしたものとして考える。2つ目以降のグループを反転させると幸福は+2。ただし端は+1。初期スコアを求め、my_min(init_score+2*K,N-1)が答え。

  典型90 084 - There are two types of characters（★3）
  ○と×からなる文字列がある。l文字目からr文字目までの区間に○と×の両方が含まれるl,rの組の個数を求める。
  組み合わせ全体から○のみ、×のみの組み合わせを引く。
}

いもす法{
  ABC001 D - 感雨時刻の整理
  感雨時間のメモをまとめて出力する。
  5分区切りで整理して、いもす法で連続区間をまとめる。

  ABC014 C - AtColor
  0から1000000まで1000001通りの灰色の絵具について、購入する絵具の範囲のデータがN個ある。最大の購入者は何人か求める。
  いもす法を使う。

  ABC017 C - ハイスコア
  N個の遺跡を好きな順に探索できる。M種類の宝石が存在し、全種類集めてはいけない。それぞれの遺跡ではlからrまでの種類の宝石とスコアが手に入る、スコアの最大値を求める。
  想定解は全体の合計点数から覆っている区間の合計得点を引く。覆っている区間の合計得点をいもす法で求める。自力ACでは左右からの累積MAXを作り、取得しない宝石を全探索した。

  ABC035 C - オセロ 
  オセロの駒が一列に並んでいる。最初すべて黒が上を向いている。Q回区間が指定され、その間をすべて反転させる。最終的な盤面を求める。
  いもす法を使う。

  ABC153 F - Silver Fox vs Monster
  ギンギツネはN体のモンスターと戦っている。モンスターは1列に並んでおり、i番目のモンスターは座標Xiにいて体力はHiである。爆弾を座標xで使うとx-Dからx+Dの範囲のモンスターの体力をA減らすことができる。全てのモンスターの体力を0以下にするのに必要な爆弾を使う回数の最小値を求める。
  いもす法+しゃくとり法 現在地点の敵に既に与えられているダメージをいもす法で求める。爆弾ダメージの範囲外のインデックスをしゃくとり法で求める。

  ABC183 D - Water Heater
  毎分Wリットルのお湯を供給できる給湯器がある。N人おりi番目の人は時刻SiからTiまで(Tiちょうどを除く)毎分Piリットル使用する。全ての人に計画通りにお湯を供給できるか判定する。
  いもす法を使う。

  ABC187 E - Through Path
  N頂点の木があり各頂点には0が書かれている。Q個のクエリ(t,e,x)が与えられる。
  t=1ならaeiからbeiを通らず到達できる全ての頂点にxを加える。
  t=2ならbeiからaeiを通らず到達できる全ての頂点にxを加える。
  すべてのクエリ後の各頂点の数字を出力する。
  (例えば)頂点0を根にする。
  根のある側に加える場合は根にxを加え、通らない点からxを減じる。
  根のない側に加える場合は開始する頂点にxを加え、どこからも減じない。
  最後に根からいもす法を実行し、答えを出力する。
}

2次元いもす法{
  ABC106 D - AtCoder Express 2
  東西にのびる1本の線路がある。これに沿って都市1,...,Nがある。M本の列車があり、列車iは都市Liから都市Riの区間を走っている。都市piから都市qiの区間に完全に含まれる列車の本数を求める、Q個の質問に答える。
  都市の数Nの制約が500と小さいので、N^2個の2次元配列で2次元いもす法を使い、すべてのクエリにO(1)で答えられる前計算をする。
  想定解は2次元累積和だった

  典型90 028 - Cluttered Paper（★4）
  N枚の紙が軸と平行になるように配置されている。紙がちょうどk枚重なっている部分の面積をk=1,...,Nまでそれぞれ求める。
  2次元いもす法を使う
}

絶対値を外す{
  ABC166 E - This Message Will Self-Destruct in 5s
  1からNまでの番号が付いた人がいる。番号の差の絶対値が2人の身長の和に等しい組み合わせが何通りか求める。
  i<jとして絶対値を外す。mapでi+A[i]の登場回数を管理し、ans+=cnt[i-A[i]]; cnt[i+A[i]]++;を1回ループする。
}

ミニマックス法{
  ABC025 C - 双子と○×ゲーム
  直大と直子で交互に3×3のマスに○×を書く。マスには得点が付いており、右隣に同じ数、下隣の数が同じなら直大に、異なるなら直子の得点になる。両者が最善を尽くしたときのそれぞれの得点を求める。
  全探索しても9!通りの盤面。直大の手番では得点を最大に、直子は最小にするようにミニマックス法で求める。

  ABC201 D - Game in Momotetsu World
  高橋君と青木君が青と赤のマス目上で同じ駒を下か右に交互に移動する。止まったマスが青なら+1点、赤なら-1点。どちらの点が多いか求める。

  鉄則 A35 - Game 4
  N段のピラミッドの最下段に数列Aiが書かれている。最上段にコマがある。太郎、次郎が交互に下の隣り合うマスにコマを移動させる。太郎はスコアを大きく、次郎は小さくするとき、最終スコアを求める。
}

最大値の最小化{
  二分探索を見る
}

行と列で分けて考える{
  ABC023 C - 収集王
  R行C列の部屋があり、N個の飴が置かれている。マスを1つ指定し同じ行,列にある飴の個数の合計がK個になるようなマスの数を求める。
  行,列毎に飴の個数をカウントする。更にある飴の数になる行,列がいくつあるか集計する。それを使い条件を満たすマスの数を求める。更にN個の飴の位置でK+1になるならインクリメント、Kになるならデクリメント。

  ABC129 D - Lamp
  グリッドのいくつかに障害物が存在する。障害物のない位置に明かりを設置すると障害物まで上下左右に光が伸びる。1箇所に明かりを設置したときに照らされるマスの最大値を求める。
  行,列毎に障害物の位置を記録し、二分探索で照らされるマスの数を求める。

  ARC153 B - Grid Rotations
  HWのグリッドがある。各マスには英子文字が書かれている。Q回位置を指定してグリッドを縦横4つの領域に分け、各領域を180度回転する。Q回の操作後のグリッドを求める。
  行,列別に考える。各操作後に前後はつながったままである。また操作ごとに方向が反転する。これをシミュレーションする。

  ABC176 E - Bomber
  二次元のグリッド上にM個の爆破対象がある。同じ行と列の対象を爆破できる爆弾を1つ使って爆破できる最大個数を求める。
  行と列でそれぞれ爆破対象の個数を数える、行と列で最大数を求める、最大数の行と列を列挙する、交点に爆破対象がない組み合わせがあれば行と列の最大数の和が答え、1つもなければ-1したものが答え。
}

半分全列挙{
  ABC018 D - バレンタインデー
  女子がN人男子がM人いる。ここから女子P人男子Q人を選ぶ。N人の女子は合計R個のチョコレートを持っており、チョコレートiは女子xiが持っており、男子yiに渡す予定である。選択された人に女子と男子が含まれている場合のみチョコレートを渡せ、幸福度ziが発生する。幸福度の合計値の最大値を求める。
  P人の女子の選択パターンを全列挙し、各男子の価値を求めて大きい方からQ人選ぶ。これらの幸福度の最大値を得る。

  ABC074 C - Sugar Water
  100Agの水,100Bgの水,Cgの砂糖,Dgの砂糖を入れる操作ができる。水100gに砂糖Egが溶ける。ビーカーの容量はFgである。ビーカーになるべく濃い砂糖水を作るときの砂糖水と砂糖の質量を求める。
  あり得る水の量の組み合わせ、砂糖の量の組み合わせを求めて、それらの組み合わせを全探索する。

  ABC123 D - Cake 123
  1,2,3の形をしたキャンドルが付いたケーキがそれぞれX,Y,Z種類ある。それぞれのケーキには美味しさがある。1,2,3の形のキャンドルが付いたケーキを1つずつ買うとき、美味しさの合計が大きい順に1,2..K番目選び方での美味しさの合計をそれぞれ出力する。
  A,Bの組み合わせを全パターンを求め、その上位K個とCの組み合わせを全パターン求めて、順番に出力する。

  ABC184 F - Programming Contest
  T分間のコンテストでN問の問題が出題される。各問を解く時間が与えられるので、時間の総和がT以下になるように解いたときの総和の最大値を求める。
  N<=40なので半分に分けてそれぞれ全パターン求める。片方をソートしもう片方の全パターンに対する最適値を二分探索で求める。

  ABC271 F - XOR on Grid Path
  N行N列のマスがあり、各マスには非負整数が書かれている。左上からスタートし、右または下に移動を繰り返して右下に向かう。通ったマスに書かれた整数の排他的論理和が0になるようなものの総数を求める。
  半分の経路長までで半分全列挙する。

  ABC326 F - Robot Rotation

  ARC017 C - 無駄なものが嫌いな人
  要素Nの数列Aからいくつか選び、合計がXになる組み合わせがいくつあるか求める。1<=N<=32
  前半の半分全列挙でmp[合計]=出現回数を求める。後半の半分全列挙でans+=mp[X-合計]をする。

  典型90 051 - Typical Shop（★5）
  N個の区別できる品物がある。ちょうどK個を選んで値段の合計がP円以下になるパターン数を求める。
  半分全列挙して個数ごとにあり得る値段を列挙する。2つのグループの片方の個数を指定して、もう一つのグループで二分探索して条件を満たすパターン数を足し合わせる。
}

クラスカル法{
  ABC065 D - Built?
  平面上にN個の街がある。座標(a,b)と(c,d)の街の間に道を作るにはmin(|a-c|,|b-d|)のコストがかかる。任意の2つの街を行き来できるために必要な最小コストを求める。
  N^2の道を探索するとTLEする。候補となる道はx座標が隣同士の町の間か、y座標が隣同士の町の間のみなので、これらの道をvectorに格納した後、クラスカル法をする。

  ABC218 E - Destruction
  N頂点M辺の連結無向グラフがある。各辺には重みが付けられており、グラフが連結であることを保ちつつ取り除ける辺の重みの合計の最大値を求める。
  重みが負の辺は繋いだ状態からクラスカル法を使う。

  ABC235 E - MST + 1
  N頂点M辺の連結無向グラフGがある。各辺には相異なる重みが付けられている。各クエリに答える。クエリはGの辺とは異なる重みの辺を加えた時、その辺が最小全域木に使用されるか判定するものである。
  クエリの辺も含めて辺を受け取り、最小全域木を作る過程でクエリの辺が使われそうになったら使用せずにそれぞれの答えを求める。

  ABC270 F - Transportation
  N個の島がある。各島iにはコストXiで空港を、コストYiで港を建設可能。空港どうし、港どうしは行き来出来る。また1<=i<=Mの道路を島Ai,Bi間にコストZiで建設可能。任意の2つの島を行き来可能にする最小コストを求める。
  空港を建設するか、港を建設するかの4パターンを全探索し、クラスカル法でそれぞれの最小コストを求める。道路のみの場合は非連結になる可能性があるので、最後に連結要素数のチェックをする。

  ABC282 E - Choose Two and Eat One
  箱の中にN個のボールが入っており、各ボールには1以上M-1以下の整数が書かれている。この中から2つ選び、各整数をx,yとしたとき(x^y+y^x)%Mの得点を獲得する。その後どちらかのボールを食べどちらかのボールを箱に戻す。獲得可能な合計得点の最大値を出力する。
  ボールを頂点、得点を辺とした完全グラフを作成し、最大全域木を求めた時の辺の重みの合計が答え。

  PAST 201912-open L - グラデーション
  二次元平面上にN本の大きな塔とM本の小さな塔がある。各塔には色が付いている。大きな塔同士を行き来できるように橋を作る。コストは同色の塔ユークリッド距離で、異色はその10倍である。コストの最小値を求める。
  小さな塔の使用パターンを全て試す。各パターンで最小全域木を作り、最小コストを求める。

  CODE_FESTIVAL2016qualB C - Gr-idian MST(考察の一部にクラスカル法を含む)
  (W+1)*(H+1)のグリッドグラフがある。(i,j)と(i+1,j)を結ぶときはjによらずコストがpi、(i,j)と(i,j+1)を結ぶときはiによらずコストがqjかかる。最小全域木のコストを求めよ。
  コストをまとめてソートし、コストの小さい方から使う。a=W+1,b=H+1とする。W方向に結ぶ時はans+=cost*b,a--する。H方向も同様。この操作を繰り返すとコスト合計が求まる
}

BIT{
  ABC174 F - Range Set Query
  N個の色の付いた玉が並んでいる。クエリがQ個与えられる。i番目のクエリではli番目からri番目までにある玉の色の種類数を答える。
  1.ある色の玉の位置と同色の次の玉の位置の場所のペアを全て求める。これをインデックスが左端、中身が右端のvecで管理する。これはある色のひとつ前の位置をvecで管理しつつ求められる。
  2.クエリを先読みしmap mp<l,vector<P<r,クエリ番号>>>や、vvi <l,vi<r,クエリ番号>>で管理する。
  3.二次元平面上に同色の玉の区間のl,rをプロットする
  4.右から(lが大きい方から)平面走査して、lが一致する区間の点が出たらBITに追加、lが一致するクエリが出たらrがそれ以下の点の数をBITから求める。r-l+1-b.sum(r)がそのクエリの答え。

  ABC186 F - Rook on Grid
  H×Wのグリッドがあり、M個の障害物がある。マス(1,1)に飛車の駒があり、右または下に障害物を飛び越えない限り移動できる。2手以内に到達できるマスの数を求める。
  幅方向、列方向別に最も近い障害物までの距離を求める。右から下、下から右のどちらかで到達できるマスを求めて足し合わせ、どちらでも到達できるマスの数を引くと答え。前者は行ごと、列ごとに最小値を足し合わせれば求められる。後者は上から行を見ていき、まだ生きている列の分だけ足し合わせる。まだ生きている列数はBITで管理する。

  ABC221 E - LEQ
  長さNの整数列Aがある。Aの連続するとは限らない長さが2以上である部分列のうち、末尾の要素が先頭の要素以上であるものの個数を998244353で割った余りを求める。
  Aは座圧しておく。部分列の左右端の添字をl,rとするとパターン数は2^(r-l-1)=2^r*(1/2)^(l+1)。rを固定して考えると、rより左にありrの位置の数字以下の(1/2)^(l+1)の和に2^rを掛ければよい。
  左から順にrを回してBITで登場した数字の(1/2)^(l+1)の和を数字毎に管理すればこれをO(1)で求められ、N回まわすのでO(N)で実現できる。座圧内のソート、BITの使用で全体ではO(NlogN)となる。(と思う)

  ABC231 F - Jealous Two
  2人にプレゼントを1個ずつ渡す。プレゼントの候補はN種類あり、i番目の候補は1人目にとって嬉しさAi,2人目にとって嬉しさBiである。相手がもらったプレゼントの自分にとっての嬉しさが、自分がもらったプレゼントの自分にとっての嬉しさより大きくなるとけんかになる。けんかにならない渡し方は何通りあるか求める。
  各プレゼントの嬉しさを二次元平面状にプロットし、ABC174Fのように二次元平面走査をする。

  ABC285 F - Substring of Sorted String
  文字列Sが与えられる。Q個のクエリに答える。クエリ1:Sのx文字目を文字cに置換、クエリ2:Sの文字を昇順に並び替えた文字列をTとするSのl文字目からr文字目まで空なる文字列がTの部分文字列ならYes、そうでないならNoを出力する。
  クエリ2がYesになる条件は、l,r内がソートされていて、l,rよりも内側の種類のアルファベットがすべて区間内に揃っている事と言い換えられる。ソート判定のために隣り合うアルファベットが昇順になっていない箇所を1にしたBITを用意し、各アルファベットの各位置の個数を記録するため26個のBITを用意する。クエリ1はソート用BITの隣り合う位置の更新と、アルファベットの個数記録用BITの更新のみで実現可能。

  ARC031 C - 積み木
  全て高さの異なるN個の積み木が1列に並んでいる。隣り合う2個の積み木を並べ替える操作を何回か行って、一番高い積み木から順に左右に低くなっていくようにするとき、必要な最小の交換回数を求める。
  低い積み木から順に左右どちらかの端に移動するか決める。BITをすべて1で初期化し、低いものから順に左右どちらに移動するか決める。その後対象の要素に0をセットする。

  ARC033 C - データ構造
  数の集合Sに対する次のクエリを処理する。タイプ1:Sに数Xを追加する タイプ2:Sに含まれる数のうちX番目に小さい数を答えその数をSから削除する。
  BITかセグ木で各数の登場回数を管理する。タイプ2のクエリでは自分以下の数がX個以上になる最小の数を二分探索で求める。

  ARC048 B - AtCoderでじゃんけんを
  じゃんけん大会を行う。それぞれが固定された手のみを出し、総当たり戦をする。勝敗は次の通り。レートが高い方が勝ち、レートが同じなら手が強い方が勝ち、レートも手も同じなら引き分け。各人が何勝何敗何引き分けか求める。
  BITとmapで解いたが、累積和でも解ける。
}

転倒数{
  ABC190 F - Shift and Inversions
  0からN-1までを並べ変えた数列Aが与えられる。それを1つずつ左にシフトさせたBの転倒数を各シフト数で求める。
  BITで初期状態の転倒数を求める。シフトは1つずつ左の要素を失くして減少、右に追加して加算する。

  ABC296 F - Simultaneous Swap
  長さNの数列A,Bが与えられる。相異なる整数i,j,kを選び、Aの要素i,jを交換し、Bの要素j,kを交換することを何度でも行える。AとBを一致可能か判定する。
  多重集合として異なればNo。全ての要素が異なるなら任意の要素の交換で転倒数の偶奇が反転する。AとBの転倒数の偶奇が同じなら達成可能。またAに同じ数字が含まれている場合偶奇をどちらにもできるので達成可能。
  
  ARC120 C - Swaps 2
  長さNの数列A,Bが与えられる。次の操作を繰り返してAをBに一致させるのに必要な最小の操作回数を求める。位置不可なら-1を出力する。
  操作 1.AiとAi+1を入れ替える 2.Aiに1加える 3.Ai+1から1減じる
  A,Bともに位置の分だけ数を加えたものに変換すると、Aの各要素をどこに移動すべきか分かる。Aの各要素を位置に置き換えて転倒数を求めると答え。

  ARC136 B - Triple Shift
  長さNの整数列A,Bがある。Aの連続する3つを選択して右方向に移動する操作を好きな回数実行して、AをBに一致させられるか判定する。
  まず多重集合として一致しているか調べ、一致していなければ不可能。次に集合内に同一の数字がある場合は必ず達成できる。最後に問題で設定された方法は偶置換であり、A,Bの転倒数の偶奇性が一致していればよい。
}

XOR{
  ABC098 D - Xor Sum 2
  整数列Aがある。Al^...^Ar=Al+...+Arとなるl,rの組の個数を求める。
  Aの累積和とAの累積XORを前計算する。lを固定して全探索し、rを二分探索で求めて各lに対して条件を満たすrの個数を求める。

  ABC121 D - XOR World
  AからBまでの数すべてのXORを求める。
  0からAまで、0からBまでの2進数表記での各桁の1の個数の和の差分を求めて計算する。
  上記はO(logN)だが、別解で、0スタートの区間2のXORは1になる性質を利用したO(1)の解法がある。

  ABC126 F - XOR Matching
  長さ2^(M+1)の数列であり、各要素に0以上2^M未満の整数をちょうど2つずつ含み、ai=ajを満たす任意のi,jについて、ai^ai+1^...^aj=Kを満たすものがあればそれを構築する。
  0,1,..,K,1,0,Kが答え。K>=2^MとM=1,K=1が構築不可。M=1でもK=0は{0,0,1,1}とする事で構築可能。

  ABC147 D - Xor Sum 4
  N個の整数がある。全ての2つの組み合わせをXORしたものの合計を10^9+7で割った余りを求める。
  XORは桁毎に独立して計算できる。int msk = 1LL<<iを使って桁毎に0,1の個数を数え、ans+=mint(msk)*one*zeroを計算していく。ここでmskを作るとき1LLとしないと32bitの次に最初の桁に戻るので注意。

  ABC171 E - Red Scarf
  猫がN(偶数)匹いる。猫には1,2,...,Nの番号が振られている。各猫は首にスカーフを巻いており、スカーフには非負整数が1つ書かれている。各猫について自分以外の猫のスカーフのXORが与えられる。各猫のスカーフの元の数を求める。
  Nは偶数なので、すべてのAのXORをとると、元の数全てのXORになる。元の数全てのXORと、ある数以外のXORをとると、元の数になる。

  ABC201 E - Xor Distances
  N頂点の重み付き木がある。dist(x,y)をxからyへの最短パスに含まれる全ての重みのXORとする。全頂点組のdistの総和を(10^9+7)で割った余りを求める。
  XORは桁毎に独立して計算できる。また、dist(x,y)はdist(0,x)^dist(0,y)と等しい。重みの桁毎に根からの重みを求め、重みが1の数*0の数に2^桁数を掛けた数を足し合わせる。

  ARC021 B - Your Numbers are XORed...
  B1,..,BLが与えられる。Bi=Ai^A(i+1)である。数列Aiを求める。該当する数列が複数ある場合、辞書順最小のものを求める。達成不可能の場合-1を出力する。
  A1=0とし、Ai=B(i-1)^A(i-1)として順番に求める。最後にA1が0でなければ達成不可能。

  ARC124 B - XOR Matching 2
  非負整数からなる長さNの数列a,bが与えられる。bを並び変えてどのiについてもai^bi=xが成立するときxを良い数と呼ぶ。良い数を全て列挙する。
  a[0]に対してbをすべて割り当て、その数tarを他も作れるか検証する。検証時、tar^aがbに存在するか調べれば良い。
}

トポロジカルソート{
  ABC223 D - Restricted Permutation
  1からNを並び替えてできる数列Pであり、1,...,Mに対しPにおいてAiはBiよりも先に現れるもののうちで辞書順で最小のものを求める。存在しない場合は-1を出力する。
  各頂点の入次数を計算し、入次数が0のものをpriority_queueに入れて使う。使った頂点の後ろの頂点の入次数を-1して入次数が0になったらpriority_queueに入れる。

  全国統一プログラミング王決定戦予選 D - Restore the Tree
  N頂点の根付き木があり、根以外の頂点には親から1本の有向辺が伸びている。このグラフにM本の新たな有向辺を書き加えた。書き足された辺はある頂点からその子孫に伸びている。元の根付き木を復元する。出力は各頂点の親を出力する。
  トポロジカルソートをして、入次数が0になったら親を記録する。
}

合成関数{
  ABC189 E - Rotate and Flip
  2次元平面にN個の駒が置かれている。M個の操作を順番に行う。操作は4種類ある。1:原点を中心に時計回りに90度回転。2:反時計回り。3:x=pに対象な位置に移動。4:y=pに対象な位置に移動。
  Q個のクエリが与えられる。i番目のクエリはAi個目の操作を行った直後にBiがある座標を出力する。
  アフィン変換で全ての操作後の変換を求め、各クエリで適切な変換をする。

  ABC196 E - Filters
  数列A,T,Xが与えられる。N個の関数をti=1ならx+ai,ti=2ならmax(x,ai),ti=3ならmin(x,ai)と定義する。Q個の値についてfN(...f2(f1(xi))...)を求める。頂点をシフトして、各頂点で答えを求める。
  合成関数はシフトとリミットを合わせたものになる。INF,-INFに順番に関数を適用してリミットを求める。シフト量も同時に求める。
}

登場位置を管理{
  ABC138 E - Strings of Impurity
  英小文字からなる2つの文字列s,tが与えられる。sを10^100個連結して得られる文字列を作る。tがその文字列i文字目までの部分列になるようなiが存在するか判定し、存在するならiの最小値を求める。
  各文字種に対して登場位置を記録する。

  ABC194 E - Mex Min
  mex(x1,...,xk)をx1,...,xkに含まれない最小の負整数と定義する。整数列Aのうちの長さMの連続する部分列でmexを求めた時、その最小値を答える。
  各数字の登場位置をvector<vector<int>>で記録しておき、0から順番に、前回登場してから次に登場するまでMより大きい間隔が空いているか判定する。各数の登場位置の記録には最後にNを番兵として入れ、最後の位置に自分自身が登場したことにする。

  Indeedなう（予選B） D - 高橋くんと数列
  長さNの数列がある。数列の各要素は1からCの整数である。1からCまでのそれぞれについて、その数を1つでも含む連続する部分列のパターン数を求める。
  各数字の登場位置を記録しておき、全パターンから対象の数字が現れないパターン数を減じる。
}

条件を満たすパターン数を掛け合わせる{
  ABC140 E - Second Sum
  {1,2..N}の順列Pが与えられる。L番目からR番目の要素のうち2番目に大きい数をXR,lとする。全組み合わせの区間のXの和を求める。
  2番目に大きな数がxであるパターン数を求める。まず順列の各数の登場位置を記録する。xが大きい順に処理する。既に処理したxの登場位置をsetに入れて記録する。xが2番目に大きくなるパターン数はset内の左右に2つ隣の要素の位置を調べることで計算し、xをかけて足し合わせることで答えを求める。
}

区間スケジューリング{
  ABC225E E - フ
  二次元平面上の第一象限にN個のフの字がある。それらから0個以上を選び削除できる。原点から全体が見える負の字は最大でいくつになるか求める。
  原点からフの左端,右端の組を構造体で持ちvectorに格納し、ソートして区間スケジューリング問題を解く。構造体のソートはoperatorをオーバーロードして実現する。

  CODE_FESTIVAL2014Easy D - 枕決め
  N人の人がおり、各人はXi以上yi以下の高さの枕を好む。M個の枕がある。好みの枕を使用可能な人は最大何人にできるか求める。
  人をxの昇順にソート、枕を昇順にソート。枕を1つずつ見て使える人全員のyをmin_priority_queueに格納。枕を使える中で最小のyを採用。使える者が出るまで取り出し続ける。

  キーエンスプログラミングコンテスト2020 B - Robot Arms
  数直線上にN個のロボットが設置されている。位置はXi、腕の長さはLiである。これらから腕の動作範囲が共通部分を持たないようにいくつか取り除くとき、残せるロボットの最大数を求める。
  pairで管理して、腕の右端でソート後に貪欲に取っていく。
}

セグ木(RMQ RangeMaxQuery){
  ABC038 D - プレゼント
  N個の箱がある。それぞれの箱はhi*wiのサイズである。ある箱は縦・横ともにより大きな箱にのみ入れられる。最大で何重の入れ子に出来るか求める。
  wの昇順、hの降順にソートし、自分より小さい箱が最大で何重かセグ木で求め、その値に+1したものをセグ木に入れる事で最大を求められる。

  ARC126 B - Cross-free Matching
  座標平面上にx座標が1,,N、y座標が0または1の合計2Nの頂点がある。これらの2頂点を結ぶ線分がM個あり、i番目の線分は(ai,0)と(bi,1)を結んでいる。線分から接しないようにK個選ぶとき、Kの最大値を求める。
  a,bを二次元平面状にプロットし、ABC174Fのように二次元平面走査をする。

  ALC Biginner Contest D - Flat Subsequence
  数列Aと整数Kが与えられる。Aの部分列で、どの隣り合う要素の差の絶対値もK以下であるものの長さの最大値を求める。
  選んだ値がiであるときの最大長をdp[i]で管理する。DPはsegtreeで構築する。最後にdp.all_prod()で最大値を求める。

  EDPC Q - Flowers
  N本の花が横一列に並んでいる。各花の高さはhiで美しさはaiである。hiは全て異なる。何本かの花を左から高さが単調増加になるように選択したときの美しさの最大値を求める。
  左から1本ずつ処理し、これまで登場した中で自分より高さが低い花の美しさの最大値を求めてそれに自分の美しさを加えたものをRMQに入れていく。加えると同時に最大値を求めるとよい。

  典型90 037 - Dont Leave the Spice（★5）
  香辛料を使う料理がN種類ある。それぞれLiからRiの範囲で使用する香辛料の量を調整できる。N種類の料理から何種類か選び、香辛料をちょうどW消費するときの価値の最大値を求める。達成不可なら-1を出力する。
  各料理を作る/作らないでdp[対象料理][使用香辛料の総量]=価値の最大値でDPをする。ある香辛料の使用量wの価値を求めるとき、dp[1つ前までの料理][w-Ri]からdp[1つ前までの料理][w-Li]の最大値を求めるが、これをセグ木で高速化する。
}

セグ木(RMQ RangeMinimumQuery){
  ARC045 B - ドキドキデート大作戦高橋君
  N個の教室が横並びになっている。M人に掃除区間が割り当てられている。1人サボっても全て掃除されるような区間を全て求める。
  いもす法で各教室に割り当てられた人数を求める。RMQで各区間に割り当てられた最少人数が2人以上ならOK。別解として最少人数が1人のところのみ残して累積和を取り、区間内の和が区間長と等しければNGと判定する事もできる。

  鉄則 B58 - Jumping
  N個の足場が横一列に並んでいる。1回でLメートル以上Rメートル以下の距離を右方向のみにジャンプできる。1からNまで最小何回でいけるか求める。
  DPをセグ木で高速化する。区間の右端を求める際は値を+1してインデックスを-1する。(実装を見る)
}

セグ木(RMQ RangeMinimumQuery){
  ABC170 E - Smart Infants
  AtCoderに参加している幼児がN人いる。幼児iのレートはAiで幼稚園Biに所属している。Q回の転園が行われる。j回目は幼児Cjの所属がDjに変更される。平等さをAtCoderに参加している園児が1人以上いる幼稚園について園内で最もレートの高い幼児のレートを求め、その最小値として得られる値とする。Q回それぞれの転園後の平等さを求める。
  multisetで各園に所属する園児のレートを管理する。区間最小セグ木(RMQ)で各園の最大レートを管理する。平等さの出力は全区間の最小値を求めて行う。
}

セグ木(GCD){
  ABC125 C - GCD on Blackboard
  N個の整数が黒板に書かれている。この中から1つ選んで好きな数に書き換える。書き換えた後のN個の整数の最大公約数の最大値を求める。
  任意の整数を削除できることと等価。GDCのセグ木に全要素を格納し、削除する1つを選んで全探索する。
}

セグ木(その他){
  ABC223 F - Parenthesis Checking
  '(',')'で構成された文字列が与えられる。クエリ1でl,rの2箇所を入れ替え、クエリ2で区間l,rが正しい括弧か判定する。
  SumとMinの組み合わせをpair型で両方計算するセグ木を作る。P op(P a,P b){return P(a.first+b.first,my_min(a.second,a.first+b.second));}で実現する。

  ABC343 F - Second Largest Query
  ;
  ;
}

遅延セグ木{
  ABC322 F - Vacation Query
  0,1からなる文字列Sが与えられる。次のクエリを処理する。クエリ1:区間[L,R]の0,1を反転する、クエリ2:区間[L,R]に含まれる連続する1の長さの最大値を出力する
  区間長さ,連続する0の最大値,左端からの0の個数,右端からの0の個数,連続する1の最大値,左端からの1の個数,右端からの1の個数,以上7つの要素を持ち遅延セグ木で処理する。

  ABC327 F - Apples
  N個のりんごが木から落ちてくる。ある時刻を選択してカゴを設置する。カゴは耐久性D長さWであり。時間DだけWの範囲のりんごを得られる。リンゴの最大数を求める。
  りんごではなくカゴの範囲を加える事を考える。各りんごが落ちるタイミングで対象区間に1を加算し、そのD後に逆操作すると全区間ないの最大値が答えになる。区間加算、最大最大取得の遅延セグ木で平面走査する。

  ABC332 F - Random Update Query
  整数列Aが与えられる。次のクエリを処理した後の各Aiの期待値をmod998244353で求める。Li以上Ri以下の整数をランダムに1つ選びApをXiに変更する。
  遅延セグ木にAffin変換を乗せる。

  ACL Beginner Contest E - Replace Digits
  https://atcoder.jp/contests/abl/tasks/abl_e
  

  AtCoder Library Practice Contest K - Range Affine Range Sum
  https://atcoder.jp/contests/practice2/tasks/practice2_k
}

平面走査{
  ABC158 E - Divisible Substring
  0から9までの数字からなる長さNの文字列がある。Sの空でない連続部分文字列のうち十進数とみなした際にpで割り切れるものの個数を求める。
  右端からmodpの値を累積和の要領で求めていく。その値が同じ組み合わせを平面操作で求める。但し***(ここを理解できていない)なのでpが2,5の場合は右端の数字がpで割り切れるかのみでカウントする。

  ABC238 F - Two Exams
  N人が試験に参加した。試験は2回で人iは1回目にPi位,2回目にQi位だった。どちらの試験でも複数人が同じ順位ではなかった。N人の中からK人の代表を選ぶ。人xが代表で上位互換の人yが代表でないということがあってはならない。代表の選び方を998244353で割った余りを求める。
  Piでソートして平面走査する。dp(i個目まで見た)[採用済みの人数][不採用の最小]=パターン数としてdpする。不採用,採用で遷移し、自分の上位互換が不採用の場合は採用しない。

  ABC245 E - Wrapping Chocolate
  N枚のチョコレートがある。縦Ai、横Biである。M個の箱がある。縦Ci、横Diである。回転せずにすべてのチョコレートを箱に入れられるか判定する。
  箱とチョコレートの両方を縦の長さの降順にvector<tuple<int,int,int>>に格納する。但し、同一サイズは箱が先になるようにする。vectorから順番に取り出し、箱ならmultisetに横の長さを格納する。チョコレートならmultisetから条件を満たす最小のものを除外する。条件を満たすものがなければNoを出力する。全てのチョコレートを処理できたらYesを出力する。

  ARC075 E - Meaningful Mean
  整数列aと整数Kが与えられる。aの空でない連続する部分列のうち算術平均がK以上のものはいくつあるか求める。
  全要素からKを減じて、累積和を取り、座標圧縮し、先頭から自分以下のものが既にいくつ現れたかを加算していく。最初に0を入れておく。

  Donutsプロコンチャレンジ2015 C - 行列のできるドーナツ屋
  N人が一列に並んでいる。各人の不安度を求める。不安度は自分より前に並んでいてある人との間にその人より大きい人がいないような人の数である。
  stackに身長を入れていく。毎回stackのサイズを出力した後、自分より低いものを全て取り除き、自分を入れる。
}

桁ごとに計算{
  ABC224 F - Problem where +s Separate Digits
  1から9までの数字のみで構成された文字列Sがある。Sの各文字の隙間に+を入れるかどうか選択する。全てのパターンの結果を加えたものを998244353で割った余りを求める。
  小さい桁から期待値を求めて、その桁の数と掛け合わせたものをansに加える。最後に全パターン数の2^(N-1)をかける。
}

右端を固定して、条件を満たす左端を高速に数え上げる{
  ABC105 D - Candy Distribution
  N個の箱が並んでおり、i番目の箱にはAi個のお菓子が入っている。lからrまでの連続した箱のお菓子の合計がMの倍数になる(l,r)の組の総数を求める。
  左から順番に、これまでのmod(M)での合計を求め、これまでの合計が同じパターンの登場回数をansに加える。その後、登場回数をインクリメントする。mod(M)でのこれまでの登場回数はmapで管理する。
}

逆操作{
  ABC068 D - Decrease (Contestant ver.)
  長さNの非負整数列に対し、数列の最大値がN-1以下になるまで以下の操作を繰り返す。
  数列の最大値の要素をN減らし、それ以外の要素を1増やす。
  整数Kが与えられるので、この操作を行う回数がちょうどK回になる数列を1つ求める。
  0からN-1までの数列に対し、逆操作をシミュレートする。但し、全体に1回ずつ操作を行う事は全体に+1することに相当するので、ループ回数を求めて残りの回数のみシミュレートする。
}

ゲーム{
  ABC059 D - Alice&Brown
  AliceとBrownでゲームをする。X,Y個の石の山があり、片方の山から2i個の石を取り、そのうちi個の石を捨て、残りi個の石をもう片方の山に置く。Aliceが先手のときにどちらが勝つか求める。
  2つの山の個数の差が1個以下が負け盤面である。abs(X-Y)<=1ならBrownの勝ち。それ以外はAliceの勝ち。

  EDPC K - Stones
  A={a1,..,aN}がある。2人で交互に、Aの中のある数の個数だけK個の石の山から石を取り除く。操作ができなくなった方の負け。どちらが勝つか判定する。
  ある個数を受け取った時に、勝ち盤面か判定する。遷移先の候補に一つでも負け盤面が含まれていればそれを渡せばよいので勝ち盤面となる。

  CADDI 2018 for Beginners
  N色のりんごがあり各色のりんごはai個ある。あなたとダックスフンドのルンルンは、木から1個以上のリンゴを選んで食べる。ただし、一度に選ぶりんごは全て異なる色でなければならない。という行動を交互に行う。最後のりんごを食べたものを勝者とするときどちらが勝つか求める。
  aiが全て偶数なら後手の勝利、1つでも奇数があれば先手の勝利。
}

LIS{
  ABC165 F - LIS on Tree
  N頂点の木がある。各頂点には整数が書かれている。1以上N以下の全ての整数kに対して、頂点1から頂点kまでの最短パス上の最長増加部分列の長さを求める。
  頂点0からdfsでLISを求めていく。戻るときにはdp配列を戻す。

  ARC133 B - Dividing Subsequence
  2つの順列P,Qがある。P,Qからそれぞれ部分列を取り出す。各部分列の要素をai,biとしたとき、biはaiの倍数であるという条件を満たす、部分列の長さの最大値を求める。
  P,Qを値→idxの配列に保存し直す。条件を満たすidxの組をpairに格納する。格納されるpairの数は調和級数の和であり、NlogNになる。これらを線とみなしたときにクロスせずに取れる最大本数が答えとなる。これはLISで求められるが、同じ数の処理を正常に行うため、biを負にしてソートした後、biを正に戻す処理をした後でLISを求めるとよい。

  ARC149 B - Two LIS Sum
  順列A,Bが与えられる。Aの2つの要素を入れ替え、対応するBの2つの要素を入れ替える操作を何度でも行える時、LIS(A)+LIS(B)の最大値を求める。
  Aの要素の内LISを構成しないものをLISを構成する位置に移動した場合ansは1増える、Bの側では減る,変わらない,増える場合があるがいずれでも合計のansが減ることはない。ここからAを昇順にソートした後のN+LIS(B)が答え。

  典型90 060. Chimera（★5）
  数列Aの部分列Bであり、要素Biまでは単調増加、Bi以降は単調減少であるもののうち最大の長さを求める。
  途中結果を記録しながら両側からLISを求める。
}

調和級数的な計算量{
  ABC272 E - Add and Mex
  長さNの整数列Aが与えられる。以下の操作をM回行う。Aiにiを加算する。その後Aに含まれない最小の非負整数を求める。
  鳩ノ巣原理より毎回の答えはN以下になり、記録すべき要素はN-1以下になる。考慮すべき要素の個数はA1はN個,A2はN/2個...と調和級数的になりNlogN個になり、全要素を列挙しても間に合う。
}

幾何{
  ABC022 D - Big Bang
  ある2つの日について同じN個の星の位置を観測した。2回目の測定は星の位置は平行移動、原点を中心にした回転、原点を中心に座標をP倍する操作を順に行ったものになっている。与えられる星の順番は同一とは限らない。Pを求める。
  それぞれの日で重心を求め、そこからの最遠点の距離を求めて割ることでPを求められる。

  ABC151 F - Enclose All
  平面上のN個の点がある。これら全てを内部または周上に含む円の半径の最大値を求める。
  最小内包円を求める問題。三分探索を使うが、まだ理解できていない。

  ABC191 D - Circle Lattice Points
  2次元平面上に中心(X,Y)、半径Rの円がある。この円の内部または周状にある格子点の個数を求める。
  誤差をなくすために10000倍した後、中心を原点近くに移動する。円の上の方からl,rを移動して境界を求める。

  ARC042 B - アリの高橋くん
  アリの高橋くんが凸多角形上の板の上にいる。現在位置から板の端点までの最短距離を求める。
  各辺との最短距離を求める。手順は2点から直線の式を求め、直線と現在位置の距離を求める。
}

内積,外積{
  AGC036 A - Triangle
  二次元平面上の3つの点(X1,Y1),(X2,Y2),(X3,Y3)を頂点とする三角形の面積がS/2であるような3点を求める。
  (X1,Y1)=(0,0)として面積は外積で考えて、x1y2-x2y1=Sとして考える。
}

グラフ構築{
  ABC108 D - All Your Paths are Different Lengths
  整数Lが与えられる。以下の条件を満たす有向グラフをひとつ構築する。
  ・頂点数Nは20以下
  ・辺数Mは60以下で0以上10^6以下の整数の長さが付けられている。
  ・全ての辺は番号の小さい頂点から大きい頂点に向かっている。
  ・頂点1からNへの異なるパスはちょうどL個あり、それらの長さは0からL-1までの相異なる整数である。
  頂点を一列に並べ、隣の頂点に重さ0と1,2,4...の辺を張っていくと0-2^(N-1)のパスができる。その後、L-2^(i-2)が2^(r-1)を超えた分だけ辺を張り、Lからその数を引く事を繰り返す。

  Tenka1 Programmer Contest D - Crossing
  (1,2..N)の部分集合の組(S1..Sk)であって以下の条件を満たすものが存在するか判定し、存在する場合はひとつ構成する。
  1..Nのうちどの整数もS1..Skのうちちょうど2つに含まれる。
  S1..Skのうちどの2つの集合をとっても、それらに共通して含まれる要素はちょうど1つである
  頂点数kの完全グラフを考える。辺数Nのkが存在する場合構築できる。完全グラフの構築は、頂点の若い順に自分より大きな番号の頂点に辺を張っていくことで行う。辺を張る度に辺番号をインクリメントする。
}

オイラーツアー{
  ABC202 E - Count Descendants
  N頂点の根付き木がある。頂点1が根である。Q個のクエリでU,Dが与えられる。各クエリに対して頂点Uの部分木であり、深さがDである頂点数を求める。
  行きがけ順(in)、帰りがけ順(out)の番号と、各頂点の深さ(d)を前計算する。深さ毎にinのリスト(ls)を作る。各クエリでの答えの候補はli[D]にある。Uの部分木である要素はin[U]からout[U]までなので、lower_boundでそれぞれ求めて、差を計算する。
}

強連結成分分解(SCC:StronglyConnectedComponents){
  有向グラフで頂点x,yが互いに到達可能なこと強連結と呼ぶ
  どのような有向グラフでも強連結な頂点のグループに分けられる
  強連結成分分解を使って同じグループの頂点を1つにまとめるとサイクルを含まないDAGになる
  SCCの求め方
  1.DFSをして帰りがけ順に番号を振る
  2.辺の向きを逆にして番号の大きい順にDFS

  ABC296 E - Transition Game
  要素数Nの数列Aが与えられる。Aの各要素は1以上N以下である。高橋君と青木君がN回ゲームを行う。各ゲームでは青木君が正整数Kを指定する。その後高橋君が1からNの整数Sを選び黒板に書く、その後黒板にxが書かれているときそれを消しAxを新たに書く事をK回繰り返す。黒板に書かれている数がiならばi回目のゲームは高橋君の勝ち。N回の内何回高橋君が勝つか求める。
  スタート地点に戻ってくるルートがあるような頂点数が答え。SCCでサイズが2以上の集合に所属する頂点数と、自分への辺を持つ頂点数を合わせたものが答え。
  
  典型90 021 - Come Back in One Piece（★5）
  N頂点M辺の有向グラフがある。頂点xからyに向かうパスとyからxに向かうパスの両方が存在する(x,y)の組の数を求める。
  強連結成分分解し、各成分内の2点を選択するパターン数を足し合わせる。
}

Mos algorithm{
  ABC242 G - Range Pairing Query
  1からNの番号の人がおり、人iは色Aiの服を着ている。以下のQ個のクエリに答える。整数l,rが与えられる。lからrの人から同じ色の服を着た2人組はいくつ作れるか答える。
  クエリをrの大きさで、√Q毎に分割する。分割された下の方からlの小さい順に計算していく。

  ABC293
}

行列累乗{
  ABC009 D - 漸化式
  数列Aはすべての要素が32ビットの符号なし整数で表現できその値は次のようにして決まる。始めのK項は入力で与えられる。Aとは別にK項の数列Cが与えられる。A(N+K)=(C1 and A(N+K-1))xor...(CK and AN)。AMを求める。
  1回の遷移を行列で表し、行列累乗する。andは掛け算、xorは足し算のように扱っても半環をなす。解説の言葉では「非負整数はxorとandに関して半環をなす」。

  ABC199 F - Graph Smoothing
  N頂点M辺の単純無向グラフがある。頂点iには最初整数Aiが書かれている。M本の辺から1本選び辺の両端の2頂点に書かれている数をその平均に置き換える操作をK回行ったとき各頂点に書かれている数の期待値をmod(10^9+7)で求められる。
  1回の操作をすべての辺に対して行ったものが操作回数1回の答え、2回以上は前の操作結果に同じ操作をしたものを求めればよい。操作を行列で表して行列累乗をする。操作は辺がなければ単位行列であり、辺1本につきその両端が1/2*Mだけ変化する事に注目して構築する。

  ABC305 G - Banned Substrings
  a,bからなる長さ6以下の空でない文字列の集合Sが与えられる。次の条件を満たす長さNの文字列Tがいくつあるか、998244353で割った余りを求める。Sの要素である任意のsiに対してTはsiを連続する部分文字列として含まない。
  5文字から次の5文字への遷移を行列で表現し、行列累乗する。それに5文字のどのパターンが存在するか表現したベクトルを掛け合わせ、全要素を合計したものが答え。Nが5未満の場合は愚直に数え上げる。

  EDPC R - Walk
  N頂点の単純有向グラフGがある。Gの長さKの有向パスは何通りか、10^9+7で割った余りを求める。
  1<=K<=10^18と大きい。1回の遷移を行列で表し、行列累乗する。

  CODE FESTIVAL 2014 Middle C - eject
  エアコンのスイッチを遠隔で切り替える。初期状態OFF、確率pで遷移するとき、n回切り替えを試みた後にONである確率を求める。
  行列累乗すれば良いが、浮動小数点の誤差に対応するため毎回正規化する。
}

処理の打ち切り{
  東京海上日動 プログラミングコンテスト2020 C - Lamps
  直線上に電球がN個並んでいる。初期状態ではそれぞれ半径Aiの範囲を照らす。次の操作をK回繰り返した後の各電球の光の強さを求める。自分を含めて自分を照らす電球の個数の光の強さにする。
  シミュレーションして状態が変わらなくなったら打ち切ればよい。
}

インタラクティブな問題{
  ABC019 D - 高橋くんと木の直径
  木の直径をインタラクティブに求める。最初に頂点数が与えられ、2頂点を指定するとその間の距離が返される。
  木の直径は根から最遠の頂点から、最遠頂点までの距離で求められる。

  ABC313 D - Odd or Even
  整数NおよびN未満の奇数Kが与えられる。ジャッジシステムは0および1からなる長さNの数列Aを隠し持っている。K要素の合計の偶奇を問う質問をN回まで行うことで数列Aを特定する。
  先頭K+1要素のうち1つのみを除外した質問を行い合計する。Kは奇数なのでこの合計は先頭K+1要素の合計の偶奇と一致する。この全体の偶奇とこれまでの各質問の偶奇を合わせることで先頭K+1要素を特定する。その後先頭K-1要素を用いて未特定用を1つずつ特定する。

  AtCoderPetrozavodskContest001 C - Vacant Seat
  Nを3以上の奇数とする。Nこの席が円状に並んでいる。各席は「空席」「男性」「女性」のいずれかの状態であり、同性が隣り合う事はない。どれか1つの空席を20回以内の質問で当てる。
  はじめ席0を尋ねる。その後、半分ずつ尋ねて空席がある側を絞り込む。
}

答えへの貢献度を考える{
  ABC173 F - Intervals on Tree
  N頂点の木がある。f(L,R)をL以上R以下の頂点からなる頂点集合と両端とも集合に属する辺から成る部分グラフの連結成分の個数と定義する。全てのL,Rにおけるf(L,R)の合計を求める。
  辺が存在しない場合の合計を計算する。各辺が何パターンで出現するか考えて合計から減じたものが答え。

  ABC312 G - Avoid Straight Line
  N頂点の木がある。1<=i<j<k<=N且つ頂点i,j,kをすべて含む単純パスが存在しないような(i,j,k)の個数を求める。
  余事象は2頂点間の距離-1を全ての頂点の組み合わせで求めたもの。これは典型90 039で求めたものからNC2を減じたもの。全パターンであるNC3から余事象を減じたものが答え。

  AGC005 B - Minimum Sum
  順列Aがある。あり得るすべての区間について、最小要素を求め、その総和を求める。
  数字ごとに貢献度を求めて数字に掛ける。数字が小さい順にsetに入れて左右にどこまで伸ばせるか求めるようにする。最初に番兵として0,N+1を入れると良い。

  典型90 039 - Tree Distance（★5）
  N頂点の木がある。異なる2頂点の全組み合わせの間にある辺の数の総和を求める。
  根付き木として、全ての頂点について自分以下の要素数をdfsで求める。自分以下のグループの要素とそれ以外の要素から1つずつ選択されたとき、自分の親に繋がる辺が使われるので、異なるグループの要素数の積の総和が答え。
}

高速ゼータ変換{
  ARC100 E - Or Plus Max
  長さ2^Nの整数列がある。1<=K<=2^N-1を満たすすべての整数Kについて次の問題を解く。0<=i<j<=2^N-1且つ(i|j)<=KのときAi+Ajの最大値を求める。
  高速ゼータ変換の要領で大きい方から2番目までの要素を保存する処理をする。処理後にそれぞれについて2つの要素を合計する。問題の要求に従い累積maxを取る。
}

永続データ構造{
  ABC273 E - Notebook
  整数列Aとノートがある。ADD,DELETE,SAVE,LOADからなるQ個のクエリを実行直後のAの末尾を出力する。
  木構造と現在位置で管理する。
}

最大フロー,最小カット{
  ABC318 G - Typical Path Problem
  N頂点M辺の単純無向グラフGが与えられる。G上の相異なる頂点A,B,Cが与えられる。頂点Bを経由して頂点A,Cを結ぶ単純パスが存在するか判定する。(単純パスは登場する頂点が全て異なる)
  同じ頂点を1度しか使わないようにするためin,outを分け、頂点内でin→outに辺を張る。超頂点からA,Cのinへ1を流し、超頂点からBのinへの最大流が2なら条件を満たす単純パスが存在する。

  ARC074 F - Lotus Leaves
  H行W列のマス目状の長方形の池がある。池には蓮の葉が浮かんでおり、葉Sにはカエルがいる。葉から葉に縦横のみに移動可能。葉Tまでの移動を不可能にするために除去する最小の枚数を求める。不可能にできなければ-1を出力する。
  スーパー頂点からSに,Tからスーパー頂点に容量INFの有向辺を張り、蓮の葉同士にも有向辺を作り、最小カットを求める。

  鉄則 B69 - Black Company 2
  N人の働ける時間帯が与えられる。各人は1日に10時間までしか働けない。全ての時間帯にM人以上が勤務しているシフトを組むことが可能か判定する。
  sから各人に容量10の辺を張る。各人から勤務可能な時間帯に容量1の辺を張る。時間帯からtに容量Mの辺を張る。最大フローがM*24ならシフトを組む事が可能。
}

ダブリング{
  ABC013 D - 阿弥陀
  あみだくじをD回縦に連結したものについて、各始点がどの終点になるか求める。
  ダブリングする。
  
  ABC136 D - Gathering Children
  マスの情報を表す、L,Rで構成された文字列Sがある。N個のマスが左右一列に並んでおり、各マスには1人ずつ配置されている。Lのマスは次のターンは左に、Rは右に移動する。10^100ターン後の各マスの人数を求める。

  ABC167 D - Teleporte
  N個の町があり、各町にはテレポーターが1台ある。各テレポーターの遷移先は町Aiである。町1からK回テレポーターを使用するとどの町に到着するか求める。

  鉄則 A57 - Doubling
  N個の穴に一匹のアリが住んでいる。穴iの翌日には穴Aiに移動する。Q個のクエリに答える。クエリは今xにいる場合、y何日後にはどの穴にいるか。
}

ローリングハッシュ{
  ABC284 F - ABCBAC
  文字列Sおよび整数iに対してfi(S)を、Sの先頭i文字,Sを反転した文字列,Sの末尾N-i文字を連結したものと定義する。長さ2Nの文字列Tが与えられる。fi(S)=Tを満たす文字列Sを求める。存在しない場合は-1を出力する。
  順方向、逆方向のローリングハッシュを構築して1箇所ずつ判定する。

  鉄則 A56 - String Hash
  文字列Sが与えられる。Q個のクエリに答える。S[ai,bi]とS[ci,di]は一致するか。
  ローリングハッシュを構築して答える。
  
  鉄則 B56 - Palindrome Queries
  文字列Sが与えられる。Q個のクエリに答える。S[Li,Rl]は回文か。
  順方向、逆方向のローリングハッシュを構築して判定する。
}

ハッシュ{
  N個の整数A(各Aは最大1000桁)が与えられる。Ai*Aj=Akとなる整数の組(i,j,k)の個数を求める。
  素数上のmodにして判定を行う。素数1つだけでは不安なので10個程度選ぶ。判定にはmap<vi,int>を用い、mp[vi(A0(mod0),A0(mod1),...)]=1を各Aで格納しておき判定する。
}

主客転倒{
  
}

言い換え{
  ARC143 A - Three Integers
  非負整数A,B,Cがある。2つの整数を選んでそれらから1を引く、すべての整数から1を引くの2つの操作を好きな順で好きな回数繰り返せる。すべての数を0にできるか判定し、可能なら操作回数の最小値を求める。
  2つの整数から引く操作は1つの整数に1を足した後ですべての整数から1を引くと言い換えられる。A<=B<=Cとしたとき、C>=(C-A)+(C-B)を満たすとき達成可能で、操作回数はC。満たさなければ達成不可。
}

Sparse Table{
  ABC282 F - Union of Two Sets
  インタラクティブな問題。ジャッジから整数Nが与えられる。1以上50000以下の整数Mを出力する。M個の区間を出力する。Q個の区間を表すクエリが与えられるので、その区間を被覆できる2つの区間の番号を答える。
  Sparse Tableを構築して答える。
}

ハブにまとめる{
  ABC257 F - Teleporter Setting
  N個の町とM個のテレポーターがあり、町は1..Nと番号づけられている。テレポーターは2つの町を双方向に結び1分間で移動できる。片方が未定のテレポーターは各クエリでもう片方を決める。i=1..Nについて、未定のテレポーターのもう片方をiとしたときの町1からNまでの移動時間の最小値を求める。移動不可なら-1を出力する。
  未定のテレポーターの行先を町0として、町1から各頂点への最短距離、町Nから各頂点への最短距離を求める。あり得るのはテレポーター不使用、iからテレポーターのある町、テレポーターのある町からiの3パターン。つまり答えは1からN、1からi+0からN、1から0+iからNの最小値。テレポーター→i→テレポーターのケースもカバー出来ている。
}

中国剰余定理{
  ABC186 E - Throne
  円周上にN個の椅子が並べられておりそのうち1つは玉座である。高橋君は玉座からS個隣の椅子に座っている。K個隣の椅子に移動し座る行動を何回繰り返すと玉座に座れるか求める。座れない場合は-1を出力する。T個のテストケースに答える。
  求めるものはS+Kx≡0(modN)を満たすxである。Kx=yとおき、y≡0(modK)、y≡-S(modN)の連立合同式を中国剰余定理で解き、x=y/Kで答えを求める。

  ABC193 E - Oversleeping
  街AとBを往復する電車がある。AからX秒かけてBに移動に移動し、BでY秒停車し、X秒かけてAに移動し、AでY秒停車する事を繰り返す。高橋君はAを出発しBで降りようと思っている。P秒間眠りQ秒間起きる事を繰り返す。Bで降りられるか判定し、降りられる場合は最短でいつになるか求める
  条件を満たすtはX<=t(mod2X+2Y)<X+Y、P<=t(modP+Q)<P+Qを共に満たすもの。YとQが小さい事を利用して全探索する。

  ACL Contest 1 B - Sum is Multiple
  整数Nが与えられる。正の整数kであって(1+..+k)がNの倍数になるもののうち最小のものを求める。
  k(K+1)=a(2N)と変形する。すると2Nの約数はkかk+1のどちらかに振り分けられる。xを2Nの約数とするとkはxで割り切れ、k+1は2N/xで割り切れる。これを中国剰余定理で解く。
  aがどうなるのかよくわかっていない
}

オイラーツアー{
  // https://wk1080id.hatenablog.com/entry/2020/05/30/004858
  ABC294 G - Distance Queries on a Tree
  N頂点の木が与えられる。辺の重みを変更するクエリと、指定された2頂点間のパスの重みの合計を出力するクエリを処理する。
  オイラーツアーで解く。
}

パズル的な問題{
  AGC006 B - Median Pyramid Easy
  N段のピラミッドがある。最下段に順列を書き込む。上の段のブロックには下3つのブロックの中央値を書き込む。最上段の数字がxになり得るか判定し、なり得るならひとつ求める。
  x=1orN-1は達成不可、それ以外は達成可。xが二つ並ぶとその上はすべてxになるので、中央にx-1,x,x+1が並ぶように配置する。

  第一回日本最強プログラマー学生選手権-予選- C - Cell Inversion
  2N個のマスが一列に並んでおり、各マスの色が文字列Sで与えられる。各マスの色は白または黒である。異なる2マスを選んでそれらの間にあるマスの色を反転する操作をN回行う(選択マスも反転する)。同じマスは2回以上選ばれない。全てのマスを白にする方法が何通りあるか10^9+7で割った余りを求める。
  区間の左右を決めた時、各操作は左端からそれらのマスの左端までを反転して右に指定したマスを反転したものに置き換えられる。各マスは1度ずつ選ばれるので左端から全マスの左端まで操作したものを前処理で用意する。これらからNペア選んで反転させる操作数が答え。先頭から平面走査的にパターン数を求め、選び方の順番を考慮しN!を掛けたものが答え。
}

牛ゲー{
  牛ゲーの解き方
  diとdj(i<j)の距離の条件が与えられたとき,d0とdN-1の距離を最大化する問題,distから構築も可能
    diとdjの距離がx以内の条件は,di+x>=djなので,di→djにコストxの辺を張る
    diとdjの距離がx以上の条件は,di+x<=djを変形してdj-x>=diなので,dj→diにコスト-xの辺を張る
  d1<=d2<=d1+1は分解して,
    d1<=d2は,d2+0>=d1なので,d2→d1にコスト0の辺を張る
    d2<=d1+1は,d1+1>=d2なので,d1→d2にコスト1の辺を張る

  ABC216 G - 01Sequence
  わからない
}

Grundy数{
  ABC297 G - Constrained Nim 2
  N個の石の山がある。山を1つ選びL個以上R個以下取り除く事を先攻後攻で繰り返し、操作できなくなった方が負け。勝者を求める。
  それぞれの山でGrundy数を求めてXORを取り、0以外なら先攻の勝ち、0なら後攻の勝ち。

  典型90 031 - VS AtCoder(★6)
  N個の石の山がある。それぞれ白石がWi個、青石Bi個ある。先攻後攻が交互に次の操作のいずれかを行う。操作1:w>=1のとき選んだ山に青石をw個加えて白石を1個取り除く。操作2:b>=2のとき1以上b/2以下の整数kを選び選んだ山から青石をk個取り除く。どちらが勝つか答える。
  各石の組み合わせ毎にGrundy数を求めてXORを取り、0以外なら先攻の勝ち、0なら後攻の勝ち。

  DISCO presents ディスカバリーチャンネルコードコンテスト2020本戦 A - Div/de
  N個の正の整数がある。先攻後攻で次の操作をする。2以上の整数を1つ選びより小さい正の約数に書き換える。操作ができなくなった方が負け。どちらが勝つか判定する。
  各数を素因数分解してその個数同士でxorを求め、0なら後攻の勝ち、そうでないなら先行の勝ち。

  TTPC2019 D - 素数取りゲーム
  N個の石の山がある。先攻後攻で1つの山を指定して素数個の石を取り除く。但し、残った石の数も素数個にならなければならない。石を取り除けなくなった方が負け。勝者を求める。
  素数はほとんど奇数なので、素数-素数が素数になるパターンは少ない。これが成り立つのはどれか1つが2の場合のみ。この事実から遷移先は3パターンなので愚直にGrundy数を求める。
}

構築{
  ARC007 B - Construct Sequences
  順列pが与えられる。次の4条件をすべて満たす整数数列a,bを構成する。条件1:1<=ai,bi<=10^9 条件2:a1<..<aN 条件3:b1>..>bN 条件4:ap1+bp1<..<apN+bpN
  まずすべてのiについてai+biが等しく,間が離れるように初期化する。例えばaiは30000*(i+1)とする。その後、pに従いaに値を加える。

  ARC115 C - ℕ Coloring
  次の条件を満たす長さNの正の整数列のうち現れる値の最大値が最小になるものを一つ出力する。条件:iがjの約数ならばAi!=Aj
  想定解はAiをiの約数の個数にする事。自分の解法は逆に大きい方から約数を求め、それぞれの約数をchmaxするもの。

  ARC118 C - Coprime Set
  要素数Nの数列であって、次の条件を満たすものを構築する。1<=Ai<=10000、全ての要素が異なる、gcd(Ai,Aj)>1、gcd(A1,A2,..,AN)=1
  {a1,..,an}が条件を満たすならばaiの倍数をさらに追加しても再び条件を満たす。{6,10,15}で開始すると2666元集合が実現でき、{6,10,14,22,1155}で開始すると2926元集合が実現できる。

  ARC142 B - Unbalanced Squares
  N*Nのグリッドに1からN*Nの数字を1つずつ書き込む。各マスについて自分より小さい数の個数=大きい数の個数にならないようなものを1つ出力する。
  半分より大きい数と小さい数に分ける。解法1:市松模様に敷き詰める。解法2:奇数行、偶数行で分ける。

  ARC149 C - Avoid Prime Sum
  N行N列のマス目がある。各マスについて4方向に隣接する数との和がどれも素数でないように、N^2以下の正整数を1つずつ書き込む。
  基本的には偶奇で固め、境界部分はmod3で組み合わせる。合計3を避けるために7を先にqueueに入れた。解説ではN<=5を埋め込み、N>6はmod3=0を境界部分に並べる。

  第一回日本最強プログラマー学生選手権-予選- D - Classified
  N個の部屋があり、どの2部屋の間にも直接結ぶ通路が1本ある。全ての通路にレベルを設定する。全ての部屋について、部屋iから出発してレベルが等しい通路のみをいくつか通って部屋iに戻るとき、通路を通る回数が必ず偶数になるようにする。レベルの最大値を最小化するように構築する。
  各部屋に番号を設定する。ある2部屋の間の通路のレベルは、部屋番号を二進数で見たときに異なる桁のレベルに設定可能なのでレベルの低い方から設定可能か調べればよい。これは各レベルの通路が二部グラフになっていればよいことから成立する。
}

両側から求める問題{
  ABC291 F - Teleporter and Closed off
  N個の都市があり、一方通行のテレポーターで移動できる。移動は右方向の10都市以内で指定される。k=2,..N-1の都市がそれぞれ封鎖されたときの都市1からNまでの最小の移動回数を求める。
  逆方向のグラフも作成して左右からの距離を求める。ある都市が封鎖されたときにその都市を跨ぐルートを全探索する。
}

数式の変形{
  ARC158 B - Sum-Product Ratio
  0でない整数x1,..,xNが与えられるi,j,kを1<=i<j<k<=Nを満たす整数とするとき(xi+xj+xk)/xi*xj*xkの最大値と最小値を求める。
  他2つを固定するとa/x+bと変形できる。他の2数の結果と大小どちらを目指すか考えると、xの逆数をなるべく大きいか小さくしたい。よって1/xの大きい方小さい方から3つずつを選択し、全探索すればよい。
}

平均値の最大/最小化(二分探索){
  ABC294 F - Sugar Water 2
  砂糖Aiグラム水BiグラムからなるN本の砂糖水と、砂糖Ciグラム水DiグラムからなるM本の砂糖水がある。それぞれから1本ずつ選んで混ぜる方法のうち、濃度が高い方からK番目の砂糖水の濃度が何%であるか求める。
  題意より、「x%以上がK個以上であるようなxのうちの最大値」を求める事に相当する。濃度がx%以上であるとは、A+C/(A+B+C+D)>=xを満たす事である。A+BをB,C+DをDと置き直すとA+C/(B+D)>=x。これを変形してA-Bx>=Dx-CとしてN本とM本を分離する。xを100回程度の二分探索で試し、それぞれのループ内では二分探索や尺取り法で条件を満たすパターン数をカウントする。

  ABC324 F - Beautiful Path
  N頂点M辺の有向グラフがある。各辺には美しさとコストの2つの正整数値が定められている。各辺は頂点番号が大きくなる遷移をする。頂点1からNへのパスPを1つ選んだときのP上の美しさの総和をコストの総和で割った値の最大値を求める。
  「美しさ合計/コスト合計>=X」を変形して,「美しさ合計-コスト合計*X>=0」とする。Xを決め打ち各辺の重みを「美しさ-コスト*X」と再定義すると頂点1からNまでのパスの重みの最大値が0以上になればXを達成可能。これをdp[i]=頂点1からiまでのパスの重みの最大値として解く。

  PAST 201912-open M - おまかせ
  N体のモンスターとM体のお助けモンスターがおりそれぞれ質量と魔力が設定されている。この中からちょうど5体を選び合成する。ただしお助けモンスターは1体までしか選べない。合成後のモンスターの強さを「魔力の和/質量の和」と定義する。合成後のモンスターの強さの最大値を求める。
  「魔力の和/質量の和=x」を変形して、「魔力の和-質量の和*x=0」とする。xを決め打って達成できるか判定する。
}

平方分割{
  ABC335 F - Hop Sugoroku
  N個のマスと長さNの数列Aがある。最初マス1のみが黒く、マス1にコマがある。「コマがマスiにあるときある正整数xを決めてコマをマスi+Ai*xに移動させてコマのあるマスを黒くする」操作を0回以上好きなだけ繰り返す。黒く塗られたマスの集合として考えられるものを998244353で割った余りを求める。
  Aiが√Nより大きいかで操作を分ける。小さい場合は剰余毎に貯めておく,大きい場合は愚直シミュレーション。
}

数学{
  ToyotaProgrammingContest2023SpringFinal A - Area Sum
  N行M列からなる盤面があり左上から1からN*Mまでの整数が書かれている。この盤面の部分長方形であって、内部に書かれた値の総和がちょうどVになるものの個数を数える。
  矩形サイズ(h,w),左上の数aを固定すれば合計VがO(1)で求められる。これを変形して矩形サイズ(h,w)を固定すれば合計がVになるようなvが存在するか判定できる。矩形サイズ(h,w)を全探索して合計がVになるようなaが存在するか判定する。
}

全体から減じる{
  OUPC 2023 Day1 : 大阪大学セット B - Gomamayo
  文字列Sに対して次の条件を満たす長さ1以上の文字列A,Bが存在するとき、Sは「ゴママヨである」という。SはA,Bをこの順で連結した文字列に等しくAの最後とBの最初の文字が等しい。Sの連続部分文字列であってゴママヨであるようなものの個数を998244353で割った余りを求める。
  全パターンからゴママヨでないパターンを減じる。長さlのパターンはl*(l-1)/2。
}

LCA(最小共通祖先){
  PAST 201912-open K - 巨大企業
  N人の社員が存在する。社長は一人であり上司を持たない、他の社員はちょうど一人の直属の上司を持つ。Q個の社員の組(a,b)が与えられるので、aがbの部下であるか判定する。
  LCAを使う。
}

Trie木{
  ABC287 E - Karuta
  N個の文字列が与えられる。各文字列について、他のいずれかの文字列と共通のプレフィックスの最大長を求める。
  すべてTrie木に挿入し、プレフィックスの登場回数が2以上になる最大長が答え。
  ソートして左右と比較でも良い

  ABC377 G - Edit to Match
  N個の文字列が与えられる。各文字列について、それより前に出現した文字列に一致させるために数文字削除して数文字追加する操作をする場合の操作回数の最小値を求める。
  操作回数は対象の文字列の共通部分より後の部分の長さの合計値。Trie木にそれを載せて求める。
}

その他{
  ABC031 D - 語呂合わせ
  数字と語呂合わせの組がN個与えられる。各数字の語呂合わせを求める。
  各数字の語呂合わせを生成して検証すると(26^3+26^2+26)^9となりTLE。各数字の文字数を決め打って検証するとO(3^K*Σ|wi|*K)となり間に合う。

  ABC045 D - すぬけ君の塗り絵
  H行W列のマス目がある。このうちNマスを黒く塗った。盤の中に完全に含まれるすべての3行3列のマス目のうち、黒いマスがちょうどj(0-9)個あるものの個数をそれぞれ求める。
  見るマス目の範囲を変えるのではなく、周囲のマスのカウントをインクリメントして、各マスのカウントを数える事にする。j=0のみ他の答えから最後に計算する。

  ABC062 D - 3N Numbers
  Nを1以上の整数する。長さ3Nの数列aがある。aからちょうどN個の要素を取り除き、残った2N個の要素を元の順で並べる。その前半N個の合計-後半N個の合計の最大値を求める。
  N番目から2N番目まで区切りを試し、区切りの前N個の最大値-後N個の最小値を計算していく。前計算として最大値、最小値をqriority_queueで値を管理しながら求めておく。

  ABC083 D - FT Robot
  二次元平面上の原点にロボットが置かれている。最初右を向いている。FTの文字列からなる命令が与えられる。Fは向いている方向に進む。Tは右または左に90度回転する。命令後に座標(x,y)に存在できるか判定する。
  x,y方向で別々に考えられる。bitsetで管理すると速い。

  ABC083 D - Wide Flip
  0,1からある文字列Sが与えられる。Sの長さK以上の連続する区間の値を反転させる操作を好きな回数行い、すべて0にできるような最大の整数Kを求める。
  Sの長さの半分までは必ず達成できる。長くしていくと中心部分はどうやっても毎回反転させてしまうので、中心部分が同じ数字の分だけKを大きくする事ができる。

  ABC096 D - Five, Five Everywhere
  条件を満たす長さNの数列を1つ出力する。1.要素は55555以下の素数、2.全ての要素が異なる、3.どの異なる5個の要素を選んでも合計が合成数になる。
  素数で且つ5の剰余が1の数字を並べていくと答えが得られる。

  ABC099 D - Good Grid
  N行N列のグリッドがあり、それぞれのマスは色1からCまでのいずれかの色で塗られている。(i+j)%3=(x+y)%3ならば同色、それ以外は別の色になるように色を塗りなおす。色XをYに塗り替えた時の違和感がDXYで与えられる。違和感の和の最小値を求める。
  同色にするマスのグループは3つに分かれる。各グループをある色にしたときの違和感の和を前計算し、全パターン試して最小値を求める。

  ABC126 E - Roadwork
  1本の道の上でN回の道路工事が行われる。それぞれSi-05からTi-0.5まで座標Xiを通行止めにする。Q人の人が座標0に立っている。i番目の人は時刻Diに座標0を出発し、速度1で正の方向へ歩き続け、通行止めになっている地点に到達すると停止する。Q人それぞれが進む距離を求める。
  工事の座標をx、開始をs、終了とtとし、vector<tuple>に(x,s-x,t-x)として格納してソートする。Q人をset<P>にP(d,i)として格納する。工事をスタート地点に近い方から取り出し、開始時刻以降の人を順番に取り出して、答えにxを入れてsetから除外する。終了時刻以降の人が出たら、次の工事について同じことを行い、全員分の答えを求める。

  ABC131 E - Friendships
  N頂点の無効グラフで、頂点間の最短距離が2であるような頂点対がちょうどK個のものを1つ構築する。
  最短距離が2であるものが最大になるのはスター型のとき、そこから連結度を高めていき構築する。

  ABC147 C - HonestOrUnkind2
  正直者の最大数を求める

  ABC164 D - Multiple of 2019
  1から9までの数字から成る文字列Sが与えられる。Sのi文字目からj文字目までを10進数の整数と見たとき、2019の倍数であるi,jの組の総数を求める。
  逆元と累積和を使う。下の桁から累積和の形でmod2019で合計値を求めておく。桁uからlまでが条件に合う場合、桁uまでの累積和-桁(l-1)までの累積和が0になるので、累積和が同一になる組み合わせの和が答えになる。

  ABC166 F - Three Variables Game
  3つの変数ABCがある。N回の選択に迫られる。AB,BC,CAの何れかを指定されどちらかを-1どちらかを+1する。いずれの操作後も負の値になってはならない。N回の操作が可能か判定し、可能なら選択方法をひとつ示す。
  シミュレーションする。指定された2つのどちらも0の場合は不可、どちらか一方のみ0の場合はそちらを+1する。両方1以上なら、次のクエリを見てaが含まれていればとりあえずaの方を+1する。

  ABC169 E - Count Median
  N個の整数X1,...,XNがあり、Ai<=Xi<=Biである。X1,...XNの中央値として考えられる値はいくつあるか求める。
  中央値の最大値と最小値の間の値は全て作れるので、それを求める。

  ABC175 D - Moving Piece
  1,2,...,Nの番号のついたマスがある。マスにはそれぞれ整数が書かれている。また1,2,...,Nの順列Piが与えられる。1回以上K回以下の回数、コマがマスiにあるならコマをマスPiに移動させ、スコアにCPiを加算する。終了時の最大スコアを求める。
  順列によりマスは複数のループ区間に分けられる。開始マスを固定して全探索する。辿っていきループの長さと合計スコアを求める。その後、ループ中の終了位置を全探索して最大値を求める。このとき1ループのスコアが正なら各探索で1ループのスコア*可能なループ数をスコアに加える。

  ABC186 D - Sum of difference
  整数の組の差分の絶対値の全パターンの合計を求める
  ソートして絶対値を外す

  ABC188 F - +1-1x2
  整数Xがある。X+1,X-1,X*2の操作を好きな順序で好きな回数実行できる。XをYにするために必要な最小の操作回数を求める。
  YをXにする問題とする。+-交互の操作は無意味、++後に/2する操作は無意味である。ここから、Yが偶数なら/2し、偶数なら-1か+1する操作ができる。それらの再帰かabs(x-y)を返すメモ化再帰をする。

  ABC210 E - Ring MST
  N頂点と0辺の無向グラフがある。M種類の操作がある。i番目の操作は頂点xと頂点(x+Ai)modNを結ぶ無向辺をコストCiで追加するというもの。グラフを連結にする最小コストを求める。不可能なら-1を出力する。
  コストが低い辺から使う。iの操作で、NとAiのgcdのグループ数まで減らせる。Nをグループ数で更新して繰り返し、グループ数が1になったときのコスト合計が答え。
  MSTはMinimum Spanning Treeの略。最小全域木

  ABC216 D - Pair of Balls
  N色のボールが2個ずつありM個の筒に入っている。筒の一番上にある同色のボールを取り出していき、筒を空にできるか判定する。
  queueを上手く使う

  ARC121 B - RGB Matching
  2N匹の犬をN個の犬小屋に2匹ずつ格納する。犬はRGBの色であり、それぞれかわいさがある。同色では不満0、異色ではかわいさ差の絶対値の不満が生じる。不満の最小値を求める。
  各色が偶数匹の場合、不満は0である。R,Gが奇数の場合を考えるとR,Gの最小の差、もしくはR,Bの最小の差+G,Bの最小の差が答えの候補になるのでこれを求める。参考にした実装が賢い。

  ARC138 C - Rotate and Play Game
  N枚の1-Nの番号が付いたカードがある。各カードには整数が書かれている。すぬけ君と最小太郎君がゲームをする。まずすぬけ君が好きなカードを取り、次に最小太郎君が番号が最小のカードを取る。カードがなくなるまでこれを繰り返す。カードに書かれた整数をk個左にcyclic-shiftすることですぬけ君のスコアを最大化する。kの値と達成されるスコアを求める。
  kを適切に選ぶ事で整数の大きい方からN/2個を取れる。取らないカードを1、取るカードを-1にして累積和を取ったとき、すべての要素が0以上なら達成可能。これは累積和の最小値を一番左から更に一つ左に移動するようなkにすればよい。

  AGC016 B - Colorful Hats
  N匹の猫がいる。各猫は帽子を被っており、猫iは「自分を除く猫が被っている帽子の色の種類数はaiである」と言っている。すべての猫の発言と矛盾しないような帽子の色の組み合わせが存在するか判定する。
  aiの最大値と最小値の差が0または1でなければNo。色の種類をAとしたとき、差が0の場合、A==N-1 or 2*A<=NがYesの条件。差が1の場合はalone_cnt<mx_A and 2*(mx_A-alone_cnt)<=N-alone_cntがYesの条件。これは孤独でない猫はすべて他に1匹以上の自分と同じ色の帽子を被った猫がいることを意味する。

  AGC020 B - Ice Rink Game
  N人でKラウンドのゲームをする。各ラウンドではAi人で組を作る。組を作れなかった人は抜ける。最後に残ったのは2人である。最初のN人としてあり得る最大の人数と最小の人数を求める。
  最小の人数はl=my_ceil(l,A[i])*A[i]、最大の人数はr=(r/A[i])*A[i]+(A[i]-1)で求めていく。

  AGC029 B - Powers of two
  正整数が書かれたボールがN個ある。これらからいくつかのペアを作る。各ペアの数の和が2べきとなるものは最大いくつにできるか求める。
  数が大きい方からペアになる数が存在するかチェックする。最大の数をx、ペアをyとすると、x<x+y<2xとなりyは一意に定まる。実装はmultisetを使うと良い。

  AGC032 B - Balanced Neighbors
  整数Nが与えられる。頂点に1からNの番号がついたN頂点の無向グラフであり以下の条件を満たすものを1つ構成する。
  1.単純かつ連結
  2.ある整数Sが存在して、任意の頂点についてその頂点に隣接する頂点の番号の値の和はSとなる
  完全グラフから、辺の両端の合計値Nが奇数のときはN偶数の時はN+1となる辺を取り除いたものが答え。

  AGC033 B - LRUD Game
  HWのマス目がある。駒が一つあり、高橋君は文字列S、青木君は文字列Tに従った移動か何もしないかを選択する。高橋君はN回のステップのいずれかで盤外に移動させたい。青木君は盤上に残したい。両者が最適に行動したとき、駒が盤上に残るか判定する。
  行動順を後ろから見て、どの位置ならコマを残せるか求める。高橋君の行動で領域は狭まり、青木君の行動で領域は広がる。

  典型90 042 - Multiple of 9（★4）
  0以外の数字を使って書ける正の整数Xのうち、Xは9の倍数でXの各桁の数字の和がKになるものが何通りあるか10^9+7で割った余りを求める。
  mod9の世界ではXmod9=(Xの各桁の和)mod9が等しい事を利用する。

  CODE_FESTIVAL2016Final D - Pair Cards
  整数が書かれたカードがN枚ある。2枚のカードに書かれた整数が同一である、2枚のカードに書かれた整数の和がMの倍数である、のいずれかの条件を満たす2枚組をなるべくたくさん作る。最大何組作れるか求める。
  整数をMで割った余りでグループ分けする。余り0のグループと余りM/2のグループはグループ内のみでペアにする。それ以外は余りの組み合わせで考え、枚数が少ないグループは必ず相方のグループのカードとペアにする。多い方のグループの残ったカードでどれだけペアを作れるか求めていく。

  DISCO presents ディスカバリーチャンネル コードコンテスト2020 予選 D - Digit Sum Replace
  Xの十進表記においてある連続する2桁を選びそれらをその和で置き換える操作をXが9以下になるまで繰り返す際の最大の操作回数を求める。
  実はどのように操作しても操作回数は変わらない。2桁の合計が1桁になる場合:sum同じ,桁-1、2桁になる場合:sum9減少,桁同じ。よって答えは{dgt-1}+{(sum-1)/9}。

  JOIG 2023/2024 本戦 C - 座席 2 (Seats 2)
  N人の選手が直線状に並んでおり、各選手の出身国と位置が与えられる。各選手について自分以外の出身国の選手までの最短距離を求める。
  各選手について、左を見た場合、右を見た場合の最短距離を求める。そのために左から、右からの2回全走査する。
}

